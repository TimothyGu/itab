<%args>
	$tourn
	$event_id => undef
	$breaks_only => undef
	$debug => undef
</%args>
<%init>

	system "$Tab::logger Prepping ballots" if $debug;

	my @events;

	push (@events, Tab::Event->retrieve($event_id)) if $event_id;
	push (@events, $m->comp("/funclib/tourn_events.mas", tourn => $tourn)) unless $event_id;

	# Initialize everything by setting all the ranks and points back to the
	# real_ranks and real_points, to make sure that if settings have altered
	# since last we ran this, we can restore everything to the pristine state. 

	system "$Tab::logger Cleaning the ballots" if $debug;

	Tab::Ballot->set_sql(clean_ballots => "
							update ballot,panel,event
							set ballot.rank = ballot.real_rank, 
							ballot.points = ballot.real_points 
							where panel.id = ballot.panel 
							and panel.event = event.id
							and event.tournament = ".$tourn->id );

	Tab::Ballot->sql_clean_ballots->execute;

	system "$Tab::logger Clearing the sweep scores" if $debug;

	Tab::Entry->set_sql(clean_sweeps => "update entry,event 
							set entry.sweeps_points = 0 
							where event.type = \"speech\" 
							and event.id = entry.event
							and entry.tournament = ".$tourn->id );
	Tab::Entry->sql_clean_sweeps->execute;

	my $ballot_zero_name = "ballot_".$tourn->id;

	if ($tourn->method->mfl_time_violation == 1) { 


		# Add 1 rank to any ballot that has a time violation in it.  
		# Truncation takes care of overages.

		Tab::Ballot->set_sql( time_violations => "
				update ballot,entry
				set ballot.rank = ballot.rank + 1 
				where ballot.tv = 1 
				and entry.id = ballot.entry
				and entry.tournament = ".$tourn->id);

		system "$Tab::logger Setting time violations" if $debug;

		Tab::Ballot->sql_time_violations->execute;

		system "$Tab::logger Done setting time violations" if $debug;
	}

	# Promote any students who entryeted and lost to a disqualified entry.

	system "$Tab::logger Correcting for disqualifications" if $debug;

	Tab::Ballot->set_sql( dq_uprank => "
		update ballot as upped, ballot as dqb,entry
		set upped.rank = upped.rank - 1
		where entry.tournament = ? 
		and entry.dq = 1
		and dqb.entry  = entry.id
		and dqb.panel = upped.panel
		and dqb.judge = upped.judge
		and upped.rank > dqb.rank
		and dqb.rank > 0");

	Tab::Ballot->sql_dq_uprank->execute($tourn->id);

	# The following is a little brute force.  I could be clever about it, I
	# suppose, if I were a real programmer and not just a barely helpful
	# sysadmin.  But in the results part of the code I'm more concerned with
	# keeping it clear and clean than short and clever.  

	system "$Tab::logger Dropping worst/best scores" if $debug;

	# Drop the ballot with the worst prelim scores.
	if ($tourn->method->drop_worst_rank == 1) { 

		system "$Tab::logger Dropping worst prelim score for competitors" if $debug;

		foreach my $event (@events) { 

			foreach my $entry ($event->entries) { 

				my @ballots = $entry->prelim_ballots;

				@ballots = sort{$a->real_points <=> $b->real_points} @ballots;
				@ballots = sort{$b->real_rank <=> $a->real_rank} @ballots;

				next unless @ballots;

				my $lowest = shift @ballots;

				$lowest->rank(0);
				$lowest->points(0);

				$lowest->update;

			}

		}
	}

	# Drop the ballot with the worst elim score.
	if ($tourn->method->drop_worst_elim == 1) { 

		system "$Tab::logger Dropping worst elim score for competitors" if $debug;

		foreach my $event (@events) { 

			foreach my $entry ($event->entries) { 

				my @ballots = $entry->elim_ballots;

				@ballots = sort{$a->real_points <=> $b->real_points} @ballots;
				@ballots = sort{$b->real_rank <=> $a->real_rank} @ballots;

				next unless @ballots;

				my $lowest = shift @ballots;

				$lowest->rank(0);
				$lowest->points(0);

				$lowest->update;

			}

		}
	}


	# Drop the ballot with the worst final score.
	if ($tourn->method->drop_worst_final == 1) { 

		system "$Tab::logger Dropping worst final round score" if $debug;

		foreach my $event (@events) { 

			foreach my $entry ($event->finalists) { 

				my @ballots = $entry->final_ballots;
				next unless @ballots;

				@ballots = sort{$a->real_points <=> $b->real_points} @ballots;
				@ballots = sort{$b->real_rank <=> $a->real_rank} @ballots;

				system "$Tab::logger Dropping worst final score for competitor ".$entry->code if $debug;
				system "$Tab::logger Entry has ".scalar @ballots." ballots: @ballots " if $debug;

				my $lowest = shift @ballots;

				$lowest->rank(0);
				$lowest->points(0);

				$lowest->update;

			}

		}
	}

	# Drop the ballot with the best prelim scores.
	if ($tourn->method->drop_best_rank == 1) { 

		system "$Tab::logger Dropping best prelim score" if $debug;

		foreach my $event (@events) { 

			foreach my $entry ($event->entries) { 

				my @ballots = $entry->prelim_ballots;

				@ballots = sort{$b->real_points <=> $a->real_points} @ballots;
				@ballots = sort{$a->real_rank <=> $b->real_rank} @ballots;

				next unless @ballots;

				my $lowest = shift @ballots;

				$lowest->rank(0);
				$lowest->points(0);

				$lowest->update;

			}

		} 

	}

	# Drop the ballot with the best elim score.
	if ($tourn->method->drop_best_elim == 1) { 

		system "$Tab::logger Dropping best elim score" if $debug;

		foreach my $event (@events) { 

			foreach my $entry ($event->entries) { 

				my @ballots = $entry->elim_ballots;

				@ballots = sort{$b->real_points <=> $a->real_points} @ballots;
				@ballots = sort{$a->real_rank <=> $b->real_rank} @ballots;

				next unless @ballots;

				my $lowest = shift @ballots;

				$lowest->rank(0);
				$lowest->points(0);

				$lowest->update;

			}

		}
	}

	# Drop the ballot with the best final score.
	if ($tourn->method->drop_best_final == 1) { 

		system "$Tab::logger Dropping best final score" if $debug;

		foreach my $event (@events) { 

			foreach my $entry ($event->entries) { 

				my @ballots = $entry->final_ballots;

				@ballots = sort{$b->real_points <=> $a->real_points} @ballots;
				@ballots = sort{$a->real_rank <=> $b->real_rank} @ballots;

				next unless @ballots;

				my $lowest = shift @ballots;

				$lowest->rank(0);
				$lowest->points(0);

				$lowest->update;

			}

		}
	}

	if ($tourn->method->truncate_ranks_to > 0) {

		system "$Tab::logger Truncating ranks to an arbitrary level" if $debug;

		Tab::Ballot->set_sql( truncate => "
			update ballot,panel,event set ballot.rank = ".$tourn->method->truncate_ranks_to." 
			where ballot.rank > ".$tourn->method->truncate_ranks_to .' 
			and panel.type = "prelim"
			and ballot.panel = panel.id 
			and panel.event = event.id
			and event.tournament = '.$tourn->id.'
		'); 

		Tab::Ballot->sql_truncate->execute;

	}

	if ($tourn->method->truncate_to_smallest == 1) { 

		system "$Tab::logger Truncating ranks to the smallest panelsize" if $debug;

		# Find the size of the smallest panel.  This will be the smallest rank.
		# Note that i am not counting drops here.  That's so imbalances due to
		# drops in the middle of the day don't end up creating teeny tiny
		# panels with teeny tiny ranks and thus an unfair break
		
		foreach my $event (@events) { 

			foreach my $round ($event->rounds) { 

				Tab::Panel->set_sql( smallest => "
					select count(distinct entry.id) as countme
					from panel,ballot,entry 
					where panel.id = ballot.panel 
					and ballot.entry = entry.id 
					and entry.dropped = 0
					and panel.round = ".$round->id .'
					and panel.type = "prelim"
					and panel.id = ballot.panel
					group by panel.id 
					order by countme 
					limit 1
				');

				my $smallest = Tab::Panel->sql_smallest->select_val;
				next unless $smallest; # for events we don't handle aka debate
	
				Tab::Panel->set_sql( smallest_final => "
					select count(distinct entry.id) as countme
					from panel,ballot,entry 
					where panel.id = ballot.panel 
					and ballot.entry = entry.id 
					and panel.event = ".$event->id .'
					and panel.type = "final"
					and panel.id = ballot.panel
					group by panel.id 
					order by countme 
					limit 1
				');

				my $finalsize = Tab::Panel->sql_smallest_final->select_val;

				Tab::Ballot->set_sql( truncate => "
					update ballot,panel 
					set rank = $smallest 
					where rank > $smallest".'
					and ballot.panel = panel.id
					and panel.type = "prelim"
					and panel.round = '.$round->id.'
				');

				Tab::Ballot->set_sql( truncate_final => "
					update ballot,panel 
					set rank = $finalsize 
					where rank > $finalsize".'
					and ballot.panel = panel.id
					and panel.type = "final"
					and panel.round = '.$round->id.'
				');

			#Do it, England.
			Tab::Ballot->sql_truncate->execute;
			Tab::Ballot->sql_truncate_final->execute if $finalsize;

			} #end of foreach round

		} #end of foreach event

	}

	system "$Tab::logger Done prepping ballots" if $debug;

</%init>
