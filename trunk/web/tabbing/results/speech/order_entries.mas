<%args>
	$round
</%args>
<%init>

	return unless $round;

	my $event = $round->event;
	my $tourn = $event->tourn;

	my $seed = $tourn->start->epoch;

	#Settings
	my $mfl_time_violation = $tourn->setting("mfl_time_violation");
	my $truncate = $tourn->setting("truncate_ranks_to") if $tourn->setting("truncate_ranks_to");
	my $truncate_to_smallest = $tourn->setting("truncate_to_smallest");
	my $noshows_never_break = $tourn->setting("noshows_never_break");


	my $tb_set = $round->tb_set if $round->tb_set;

	my $equal_elims++ if $tb_set->elim && $round->type eq "elim";

	unless ($tb_set) {  
		my $err = "That round does not have a tiebreaker set applied to it.  Please pick one and try again";
		$m->redirect("/setup/schedule/event.mhtml?event_id=".$event->id."&err=$err");
	}

	my %used = (); 
	my $all;
	my $elim;

	my %tb_tiers = ();

	foreach my $tb ($tb_set->tiebreaks) { 
		$used{$tb->count}++;
		$all++ if $tb->count eq "all";
		$elim++ if $tb->count eq "elim";
		push @{$tb_tiers{$tb->priority}}, $tb;
	}   

	# Get the data you'll need for Teh Sortingz.
	my $dbh = Tab::DBI->db_Main();

    my %entry_scores;
    my %entry_panels;
	my %entry_round_scores;
    my %entry_novice;
    my %entry_school;
    my %entry_event;
    my %entry_code;
    my %entry_dq;
    my %entry_noshow;

    my %score_entry;
    my %score_tag;
    my %score_value;
    my %score_panel;
    my %score_judge;
    my %score_event;
    my %score_novice;
	my %score_tv;

	my %round_panels;

	my %panel_letter;
	my %panel_roundname;
	my %panel_entries;

	my @rounds;
	my %round_type;
	my %round_name;

    my @scores;
    my @entries;

	if ($all) { 

		my $sth = $dbh->prepare("
	        select value.id, entry.id, entry.code, entry.dq, round.type, round.name, round.id, value.tag, value.value, event.id, panel.id, 
			ballot.judge, ballot.noshow, ballot.tv, panel.letter, student.novice, entry.school
			from ballot_value value, ballot, panel, round, event, entry, entry_student, student
			where value.ballot = ballot.id
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.event = event.id
			and event.id = ".$event->id."
			and ballot.entry = entry.id
			and entry.dropped != 1
			and entry.waitlist != 1
			and entry.unconfirmed != 1
			and entry.id = entry_student.entry
			and entry_student.student = student.id
			group by value.id
			order by event.id, round.name
		");

		$sth->execute();

		while (my ($id, $entry, $code, $dq, $type, $roundname, $round, $tag, $value, $event, $panel, $judge, $noshow, $tv, $letter, $novice,  $school)  = $sth->fetchrow_array() ) {

			push @rounds, $round;
			$round_type{$round} = $type;
			$round_name{$round} = $roundname;
			push @{$round_panels{$round}}, $panel;

			push @entries, $entry;
			push @{$entry_scores{$entry}}, $id;
			push @{$entry_panels{$entry}}, $panel;
			push @{$entry_round_scores{$entry."-".$round}}, $id;

			$entry_school{$entry} = $school;
			$entry_event{$entry} = $event;
			$entry_code{$entry} = $code;
			$entry_dq{$entry} = $dq if $dq;
			$entry_novice{$entry} = $novice;
			$entry_noshow{$entry} = $noshow if $noshow;

			push @scores, $id;
			$score_tag{$id} = $tag;
			$score_entry{$id} = $entry;
			$score_value{$id} = $value;
			$score_panel{$id} = $panel;
			$score_judge{$id} = $judge;
			$score_event{$id} = $event;
			$score_novice{$id} = $novice;
			$score_tv{$id} = $tv if $tv;

			$panel_letter{$panel} = $letter;
			$panel_roundname{$panel} = $roundname;
			push @{$panel_entries{$panel}}, $entry;

		}

	} else { 

		foreach my $key (keys %used) { 

			if ($key eq "last elim" || $key eq "last_elim") { 
			
				my $sth = $dbh->prepare("
	        		select value.id, entry.id, entry.code, entry.dq, round.type, round.name, round.id, value.tag, value.value, event.id, panel.id, 
						   ballot.judge, ballot.noshow, ballot.tv, panel.letter, student.novice, entry.school
					from ballot_value value, ballot, panel, round, event, entry, entry_student, student
					where value.ballot = ballot.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.event = event.id
					and round.id = ".$round->id."
					and ballot.entry = entry.id
					and entry.dropped != 1
					and entry.waitlist != 1
					and entry.unconfirmed != 1
					and entry.id = entry_student.entry
					and entry_student.student = student.id
					group by value.id
					order by event.id, round.name
				");

				$sth->execute();

				while (my ($id, $entry, $code, $dq, $type, $roundname, $round, $tag, $value, $event, $panel, $judge, $noshow, $tv, $letter, $novice,  $school)  = $sth->fetchrow_array() ) {

					push @rounds, $round;
					$round_type{$round} = $type;
					$round_name{$round} = $roundname;
					push @{$round_panels{$round}}, $panel;

					push @entries, $entry;
					push @{$entry_scores{$entry}}, $id;
					push @{$entry_panels{$entry}},$panel;
					push @{$entry_round_scores{$entry."-".$round}}, $id;

					$entry_school{$entry} = $school;
					$entry_event{$entry} = $event;
					$entry_code{$entry} = $code;
					$entry_dq{$entry} = $dq if $dq;
					$entry_novice{$entry} = $novice;
					$entry_noshow{$entry} = $noshow if $noshow;

					push @scores, $id;
					$score_tag{$id} = $tag;
					$score_entry{$id} = $entry;
					$score_value{$id} = $value;
					$score_panel{$id} = $panel;
					$score_judge{$id} = $judge;
					$score_event{$id} = $event;
					$score_novice{$id} = $novice;
					$score_tv{$id} = $tv;

					$panel_letter{$panel} = $letter;
					$panel_roundname{$panel} = $roundname;
					push @{$panel_entries{$panel}}, $entry;
				}

			} else {

				my $sth = $dbh->prepare("
	        		select value.id, entry.id, entry.code, entry.dq, round.type, round.name, round.id, value.tag, value.value, event.id, panel.id, 
						   ballot.judge, ballot.noshow, ballot.tv, panel.letter, student.novice, entry.school
					from ballot_value value, ballot, panel, round, event, entry, entry_student, student
					where value.ballot = ballot.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.event = event.id
					and event.id = ".$event->id."
					and round.name <= ".$round->id."
					and ballot.entry = entry.id
					and entry.dq != 1
					and entry.dropped != 1
					and entry.waitlist != 1
					and entry.unconfirmed != 1
					and entry.id = entry_student.entry
					and entry_student.student = student.id
					group by value.id
					order by event.id, round.name
				");

				$sth->execute();

				while (my ($id, $entry, $code, $dq, $type, $roundname, $round, $tag, $value, $event, $panel, $judge, $noshow, $tv, $letter, $novice,  $school)  = $sth->fetchrow_array() ) {


					push @rounds, $round;
					$round_type{$round} = $type;
					$round_name{$round} = $roundname;
					push @{$round_panels{$round}}, $panel;

					push @entries, $entry;
					push @{$entry_scores{$entry}}, $id;
					push @{$entry_panels{$entry}},$panel;
					push @{$entry_round_scores{$entry."-".$round}}, $id;

					$entry_school{$entry} = $school;
					$entry_event{$entry} = $event;
					$entry_code{$entry} = $code;
					$entry_dq{$entry} = $dq if $dq;
					$entry_novice{$entry} = $novice;
					$entry_noshow{$entry} = $noshow if $noshow;

					push @scores, $id;
					$score_tag{$id} = $tag;
					$score_entry{$id} = $entry;
					$score_value{$id} = $value;
					$score_panel{$id} = $panel;
					$score_judge{$id} = $judge;
					$score_event{$id} = $event;
					$score_novice{$id} = $novice;
					$score_tv{$id} = $tv;

					$panel_letter{$panel} = $letter;
					$panel_roundname{$panel} = $roundname;
					push @{$panel_entries{$panel}}, $entry;

				}
			}
		}
	}

	my %rseen = (); 
	@rounds = grep { ! $rseen{$_} ++ } @rounds;
	my @all_rounds;

	foreach my $all_round (@rounds) { 

		next if $round_name{$all_round} > $round->name;  # Do not measure the future

		push @all_rounds, $all_round;
	
		#Uniq the panels so there's no double counting
		my %pseen = (); 
		@{$round_panels{$all_round}} = grep { ! $pseen{$_} ++ } @{$round_panels{$all_round}};

		foreach my $panel (@{$round_panels{$all_round}}) {   
			#Uniq the panel entries so there's no double counting;
			my %eseen = (); 
			@{$panel_entries{$panel}} = grep { ! $pseen{$_} ++ } @{$panel_entries{$panel}};
		}

	}

	my %dq_panel_threshold = ();

	foreach my $entry (keys %entry_dq) { 
		next unless $entry_dq{$entry};
		foreach my $score (@{$entry_scores{$entry}}) { 
			next unless $score_tag{$score} eq "rank";
			$dq_panel_threshold{$score_panel{$score}."-".$score_judge{$score}} = $score_value{$score};
		}
	}

	my %round_truncate = ();

	if ($truncate_to_smallest) { 

		foreach my $round (@all_rounds) { 

			$round_truncate{$round} = $truncate;
			$round_truncate{$round} = "314159" unless $round_truncate{$round};  #Ugly hack.  Sue me.

			next unless $round_type{$round} eq "prelim";

			foreach my $panel (@{$round_panels{$round}}) { 
				my $size = scalar @{$panel_entries{$panel}} if $panel_entries{$panel};
				$round_truncate{$round} = $size if $round_truncate{$round} > $size;
			}
		}
	}

	my %eseen = (); 
	@entries = grep { ! $eseen{$_} ++ } @entries;

	if ($round && ($round->type eq "elim" || $round->type eq "final")) { 

		#Eliminate everyone who has not advanced to the elim round in question.

		my @counted;
		my %last_round;
		my %done;

		foreach my $entry (@entries) { 
			
			next if $done{$entry}++;

			foreach my $panel (@{$entry_panels{$entry}}) { 
				$last_round{$entry} = $panel_roundname{$panel} if $last_round{$entry} < $panel_roundname{$panel};
			}

			next if $last_round{$entry} < $round->name;
			push @counted, $entry;
		}

		@entries = @counted;
	}
	
	my %entry_tbs = ();
	my %tier_descs = ();
	my %tier_dir = ();

	my @rinr_rounds;

	foreach my $key (sort keys %tb_tiers) { 
		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 
			if ($tb->name eq "rankinround") { 
				foreach my $round (@all_rounds) { 
					if ($round_type{$round} eq $tb->count) { 
						push @rinr_rounds, $round;
					} elsif ($tb->count eq "all") { 
						push @rinr_rounds, $round;
					}
				}
			}
		}
	}

	my %entry_rankinround = ();

	my %rinr_seen = (); 
	@rinr_rounds = grep { ! $rinr_seen{$_} ++ } @rinr_rounds;

	foreach my $round_id (@rinr_rounds) { 

		my $round = Tab::Round->retrieve($round_id);

		my ($entries_ref, @others) = $m->comp("/tabbing/results/speech/order_entries.mas", round => $round) if $event->type eq "speech";
		($entries_ref, @others) = $m->comp("/tabbing/results/congress/order_entries.mas", round => $round) if $event->type eq "congress";

		my %absolute_rank;

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry (@{${$entries_ref}{$key}}) {
				$absolute_rank{$entry} = $key;
			}
		}
		
		foreach my $panel (@{$round_panels{$round}}) { 
			my $rank = 1;

			foreach my $entry (sort {$absolute_rank{$a} <=> $absolute_rank{$b}} @{$panel_entries{$panel}}) { 
				$entry_rankinround{$entry."-".$round} = $rank;
				$rank++;
			}
		}
	}

	foreach my $key (sort keys %tb_tiers) { 

		my $tier_desc;

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			$tier_dir{$key} = "down" if (
				$tb->name eq "reciprocals" ||
				$tb->name eq "judgepref" ||
				$tb->name eq "points" ||
				$tb->name eq "winloss" ||
				$tb->name eq "opp_wins" ||
				$tb->name eq "opp_points" ||
				$tb->name eq "judgevar");

			$tier_dir{$key} = "up" if (
				$tb->name eq "ranks" ||
				$tb->name eq "coinflip" ||
				$tb->name eq "competition" ||
				$tb->name eq "rankinround");
			
			$tier_desc .= "+" if $tier_desc;
			$tier_desc .= "Rk" if $tb->name eq "ranks";
			$tier_desc .= "Pt" if $tb->name eq "points";
			$tier_desc .= "Rcp" if $tb->name eq "reciprocals";
			$tier_desc .= "JP" if $tb->name eq "judgepref";
			$tier_desc .= "Ran" if $tb->name eq "coinflip";
			$tier_desc .= "ORk" if $tb->name eq "competition";
			$tier_desc .= "ERk" if $tb->name eq "rankinround";
			$tier_desc .= "W" if $tb->name eq "winloss";
			$tier_desc .= "OW" if $tb->name eq "opp_wins";
			$tier_desc .= "OPt" if $tb->name eq "opp_points";
			$tier_desc .= "JV" if $tb->name eq "judgevar";

            if ($tb->highlow) {
                $tier_desc .= " -".$tb->highlow_count;
                $tier_desc .= "HL" if $tb->highlow == 1 || $tb->highlow == 2;
                $tier_desc .= "H" if $tb->highlow == 3;
                $tier_desc .= "L" if $tb->highlow == 4;
            }

		}

		$tier_descs{$key} = $tier_desc;

		my %tb_rounds = ();

		foreach my $tb (@{$tb_tiers{$key}}) { 

			foreach my $oround (@all_rounds) { 
				push (@{$tb_rounds{$tb->id}}, $oround) if $round_type{$oround} eq $tb->count;
				push (@{$tb_rounds{$tb->id}}, $oround) if $tb->count eq "all";
				push (@{$tb_rounds{$tb->id}}, $oround) if $round_type{$oround} eq "elim" && ($tb->count eq "last elim" || $tb->count eq "last_elim");
			}

		}

		foreach my $entry (@entries) { 

			my $tier_total;

			foreach my $tb (@{$tb_tiers{$key}}) { 

				my $name = $tb->name;
				next unless $tb_rounds{$tb->id};
				my @rounds = @{$tb_rounds{$tb->id}};

				my $total; 

				if ($name eq "ranks" || $name eq "reciprocals") { 

					my @drop_best;
					my @drop_worst;

					foreach my $this_round (@rounds) { 

						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 

							if ($score_tag{$score} eq "rank") { 
						
								my $rank = $score_value{$score};

								if ($dq_panel_threshold{$score_panel{$score}."-".$score_judge{$score}}) { 
									$rank-- if $dq_panel_threshold{$score_panel{$score}."-".$score_judge{$score}} < $rank;
								}

								# Bump the rank up if it's a time violation.  Truncation below will correct if this makes it bigger (ie if the TV was last place);
								$rank++ if $score_tv{$score} && $mfl_time_violation;

								# Promote anyone over the hard cap for truncation
								$rank = $truncate if $truncate && $rank > $truncate && $round_type{$this_round} eq "prelim";

								# Promote anyone over the per-round floating cap for truncation
								$rank = $round_truncate{$this_round} if $truncate_to_smallest && $rank > $round_truncate{$this_round} && $round_type{$this_round} eq "prelim";

								#Rank cannot be greater than the size of the round
								$rank = scalar @{$panel_entries{$score_panel{$score}}} if $rank > scalar @{$panel_entries{$score_panel{$score}}};

								$total += $rank if $name eq "ranks";
								$total += (1/$rank) if $rank && $name eq "reciprocals";

								if ($tb->highlow) {  

									#drop the best

									if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 3) {

										if (scalar @drop_best < $tb->highlow_count) {
											push @drop_best, $rank;
										} else {
											my $least_best = pop @drop_best;
											push @drop_best, $least_best if $least_best <= $rank;
											push @drop_best, $rank if $least_best > $rank;
										}

										@drop_best = sort {$a <=> $b} @drop_best;
									}

									#drop the worst

									if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 4) {

										if (scalar @drop_worst < $tb->highlow_count) {
											push @drop_worst, $rank;
										} else {
											my $least_worst = pop @drop_worst;
											push @drop_worst, $least_worst if $least_worst >= $rank;
											push @drop_worst, $rank if $least_worst < $rank;
										}

										@drop_worst = sort {$b <=> $a} @drop_worst;
									}
								}
							}
						}
					}

                    foreach my $rank (@drop_best, @drop_worst) {
                        $total -= $rank if $name eq "rank";
                        $total -= 1/$rank if $name eq "reciprocals";
                    }

					$total = sprintf "%.2f", $total;  #round to 2 decimal places for recips;

				} elsif ( $name eq "points") { 

					my @drop_best;
					my @drop_worst;

					foreach my $this_round (@rounds) { 

						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 

							if ($score_tag{$score} eq "points") { 
					
								my $points = $score_value{$score};
								$total += $points;

								if ($tb->highlow) {  

									#drop the best

									if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 3) {

										if (scalar @drop_best < $tb->highlow_count) {
											push @drop_best, $points;
										} else {
											my $least_best = pop @drop_best;
											push @drop_best, $least_best if $least_best <= $points;
											push @drop_best, $points if $least_best > $points;
										}

										@drop_best = sort {$a <=> $b} @drop_best;
									}

									#drop the worst

									if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 4) {

										if (scalar @drop_worst < $tb->highlow_count) {
											push @drop_worst, $points;
										} else {
											my $least_worst = pop @drop_worst;
											push @drop_worst, $least_worst if $least_worst >= $points;
											push @drop_worst, $points if $least_worst < $points;
										}

										@drop_worst = sort {$b <=> $a} @drop_worst;
									}
								}
							}
						}
					}

                    foreach my $points (@drop_best, @drop_worst) {
                        $total -= $points;
                    }

				} elsif ( $name eq "coinflip") { 

					# This is only semi random; product of the date epoch and
					# the random entry ID's last four digits.  But it will be
					# the same every time this function is run and random
					# enough in that it cannot be pre-guessed easily.

					my $random_seed = $entry * $seed;
					$total = substr($random_seed, -8, -3);

				} elsif ( $name eq "judgepref") { 

					my $chosen_panel;

					my @chosen_entries;

					foreach my $this_round (@rounds) { 

						PANEL:
						foreach my $panel (@{$round_panels{$this_round}}) {    #Only counts in the current round;
							my @entries = @{$panel_entries{$panel}};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						} 

						my %beseen = (); 
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entry_tbs{$entry."-".$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) { 
							next if $oentry == $entry;
							my $test_string;
							foreach my $okey (sort keys %tb_tiers) { 
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entry_tbs{$oentry."-".$okey};
							}
							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 1) { 

							my $tie_id = shift @ties;

							my %judge_score = ();

							if ($chosen_panel && $entry) { 

								foreach my $score (@{$entry_scores{$entry}}) { 
									next unless $score_tag{$score} eq "rank";
									next unless $score_panel{$score} == $chosen_panel;
									$judge_score{$score_judge{$score}} = $score_value{$score};
								}

								foreach my $tie_score (@{$entry_scores{$tie_id}}) {
									next unless $score_tag{$tie_score} eq "rank";
									next unless $score_panel{$tie_score} == $chosen_panel;
									$total++ if $score_value{$tie_score} > $judge_score{$score_judge{$tie_score}}; #If my rank is better (lower) than the tie's rank, I get a JP point
								}
							}
						}
					}

				} elsif ( $name eq "rankinround") { 

					foreach my $this_round (@rounds) { 
						$total += $entry_rankinround{$entry."-".$this_round};
					}

				} elsif ( $name eq "opp_points") { 

				} elsif ( $name eq "opp_ranks") { 

				}

				$tier_total += $total * $tb->multiplier if $tb->multiplier;

			}

			$entry_tbs{$entry."-".$key} = $tier_total;

		}

	}

	foreach my $key (reverse sort keys %tb_tiers) { 
		@entries = sort { $entry_tbs{$a."-".$key} <=> $entry_tbs{$b."-".$key}  } @entries if $tier_dir{$key} eq "up";
		@entries = sort { $entry_tbs{$b."-".$key} <=> $entry_tbs{$a."-".$key}  } @entries if $tier_dir{$key} eq "down";
	}

	my %panel_rank = ();
	my %entry_letter = ();

	if ($equal_elims) { 

		foreach my $panel (@{$round_panels{$round->id}}) { 

			my @pan_entries = @{$panel_entries{$panel}};

			foreach my $key (reverse sort keys %tb_tiers) { 
				@pan_entries = sort { $entry_tbs{$a."-".$key} <=> $entry_tbs{$b."-".$key}  } @pan_entries if $tier_dir{$key} eq "up";
				@pan_entries = sort { $entry_tbs{$b."-".$key} <=> $entry_tbs{$a."-".$key}  } @pan_entries if $tier_dir{$key} eq "down";
			}

			my $count = 1;

			my %already; 

			foreach my $pe (@pan_entries) { 
				next if $already{$pe};
				$already{$pe}++;
				$panel_rank{$pe} = $count++;
				$entry_letter{$pe} = $panel_letter{$panel};
			}
		}
	
		@entries = sort { $entry_letter{$a} cmp $entry_letter{$b} } @entries;
		@entries = sort { $panel_rank{$a} <=> $panel_rank{$b} } @entries;
	}

	@entries = sort { $entry_noshow{$a} <=> $entry_noshow{$b} } @entries if $noshows_never_break;

	my $count;
	my %entry_by_place = ();
	
	my $last_string;
	my $delayed_count;

	foreach my $entry (@entries) { 

		my $tier_string;

		foreach my $key (sort keys %tb_tiers) { 
			$tier_string .= "-" if $tier_string;
			$tier_string .= $entry_tbs{$entry."-".$key};
		}

		if ($tier_string eq $last_string) { 
			$delayed_count++;
		} else {
			$count++;
			$count += $delayed_count;
			undef $delayed_count;
		}

		$last_string = $tier_string;
		push (@{$entry_by_place{$count}}, $entry);
	}

	return (\%entry_by_place, \%entry_tbs, \%tier_descs, \%entry_noshow, \%tier_dir, \%panel_rank, \%entry_letter);

</%init>
