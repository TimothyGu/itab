<%args>
	$round
	$equal_elims => undef
</%args>
<%init>

	return unless $round;

	my $event = $round->event;
	my $tourn = $event->tourn;

	#Settings
	my $mfl_time_violation = $tourn->setting("mfl_time_violation");

	my $truncate;
	$truncate = $tourn->setting("truncate_ranks_to") if $tourn->setting("truncate_ranks_to");
	my $truncate_to_smallest = $tourn->setting("truncate_to_smallest");

	my $noshows_never_break = $tourn->setting("noshows_never_break");

	my $tb_set = $round->tb_set if $round->tb_set;

	unless ($tb_set) {  
		my $err = "That round does not have a tiebreaker set applied to it.  Please pick one and try again";
		$m->redirect("/setup/schedule/event.mhtml?event_id=".$round->event->id."&err=$err");
	}

	my @panels;
	my @ballots;
	my @entries;
	my @values;
	my @judges;

	my %used = (); 
	my $all;
	my $elim;

	my %tb_tiers = ();

	foreach my $tb ($tb_set->tiebreaks) { 
		$used{$tb->count}++;
		$all++ if $tb->count eq "all";
		$elim++ if $tb->count eq "elim";
		push @{$tb_tiers{$tb->priority}}, $tb;
	}   


	$equal_elims++ if $tb_set->elim && $round->type eq "elim";

	# Get the data you'll need for Teh Sortingz.

	if ($all) { 

		Tab::Ballot->set_sql( get_all => "
			select distinct ballot.*
			from ballot, panel, round
			where ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
			and round.event = ?
			");

		@ballots = Tab::Ballot->search_get_all( $round->name, $event->id );

		Tab::Panel->set_sql( get_all => "
			select distinct panel.*
			from panel, round
			where panel.round = round.id
			and round.name <= ?
			and round.event = ?
			");

		@panels = Tab::Panel->search_get_all( $round->name, $event->id );

		Tab::Entry->set_sql( get_all => "
			select distinct entry.*
			from ballot, panel, round, entry
			where entry.id = ballot.entry
			and entry.dropped = 0
			and entry.unconfirmed = 0
			and entry.waitlist = 0
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
			and round.event = ?
			");

		@entries = Tab::Entry->search_get_all( $round->name, $event->id );

		Tab::BallotValue->set_sql( get_all => "
			select distinct ballot_value.*
			from ballot, panel, round, ballot_value
			where ballot_value.ballot = ballot.id
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
			and round.event = ?
			");

		@values = Tab::BallotValue->search_get_all( $round->name, $event->id );

		Tab::Judge->set_sql( get_all => "
			select distinct judge.*
			from ballot, panel, round, judge
			where judge.id = ballot.judge
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
			and round.event = ?
			");

		@judges = Tab::Judge->search_get_all( $round->name, $event->id );

	} else { 

		foreach my $key (keys %used) { 


			if ($key eq "last elim" || $key eq "last_elim") { 

				push @ballots, $m->comp('/funclib/round_ballots.mas', round => $round);
				push @panels, $round->panels;
				push @entries, $m->comp('/funclib/round_entries.mas', round => $round);
				push @judges, $m->comp('/funclib/round_judges.mas', round => $round);
				push @values, $m->comp('/funclib/round_values.mas', round => $round);

			} else {

				Tab::Ballot->set_sql( get_all => "
					select distinct ballot.*
					from ballot, panel, round
					where ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
					");

				push (@ballots,Tab::Ballot->search_get_all( $round->name, $key, $event->id ));

				Tab::Panel->set_sql( get_all => "
					select distinct panel.*
					from panel, round
					where panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
					");

				push (@panels, Tab::Panel->search_get_all( $round->name, $key, $event->id ));

				Tab::Entry->set_sql( get_all => "
					select distinct entry.*
					from ballot, panel, round, entry
					where entry.id = ballot.entry
					and entry.dropped = 0
					and entry.unconfirmed = 0
					and entry.waitlist = 0
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
					");

				push (@entries, Tab::Entry->search_get_all( $round->name, $key, $event->id ));

				Tab::BallotValue->set_sql( get_all => "
					select distinct ballot_value.*
					from ballot, panel, round, ballot_value
					where ballot_value.ballot = ballot.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
					");

				push (@values, Tab::BallotValue->search_get_all( $round->name, $key, $event->id ));

				Tab::Judge->set_sql( get_all => "
					select distinct judge.*
					from ballot, panel, round, judge
					where judge.id = ballot.judge
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
					");

				push (@judges, Tab::Judge->search_get_all( $round->name, $key, $event->id ));

			}
		}
	}

	#Dedupe
	my %jseen = (); 
	@judges = grep { ! $jseen{$_->id} ++ } @judges;

	my %eseen = (); 
	@entries = grep { ! $eseen{$_->id} ++ } @entries;

	my %bseen = (); 
	@ballots = grep { ! $bseen{$_->id} ++ } @ballots;

	my %pseen = (); 
	@panels = grep { ! $pseen{$_->id} ++ } @panels;

	my %vseen = (); 
	@values = grep { ! $vseen{$_->id} ++ } @values;

	my @all_rounds;
	my %round_by_id = ();

	foreach my $oround ($event->rounds) { 
		next if $oround->name > $round->name;  # Do not measure the future
			$round_by_id{$oround->id} = $oround;
		push (@all_rounds, $oround);
	}


	my %values_by_ballot = ();
	foreach my $value (@values) { 
		push @{$values_by_ballot{$value->ballot->id}}, $value;
	}

	my %dq_entry;
	my %entry_by_id = ();
	foreach my $entry (@entries) { 
		$entry_by_id{$entry->id} = $entry;
		$dq_entry{$entry->id}++ if $entry->dq;
	}

	my %judge_by_id = ();
	foreach my $judge (@judges) { 
		$judge_by_id{$judge->id} = $judge;
	}

	my %panels_by_round = ();
	my %panel_by_id = ();
	my %round_panel = ();

	foreach my $panel (@panels) { 
		push @{$panels_by_round{$panel->round->id}}, $panel;
		$panel_by_id{$panel->id} = $panel;
		$round_panel{$panel->id} = $panel->round->name;
	}

	my %ballots_by_panel = ();
	my %ballots_by_entry = ();
	my %ballots_by_judge = ();
	my %ballots_by_entry_panel = ();
	my %ballots_by_judge_panel = ();
	my %entry_ids_by_panel = ();
	my %judge_ids_by_panel = ();
	my %last_round = ();
	my %noshows = ();

	my %panel_ids_by_entry = ();

	foreach my $ballot (@ballots) { 
		next unless $ballot->entry;
		push @{$ballots_by_panel{$ballot->panel->id}}, $ballot;
		push @{$ballots_by_entry{$ballot->entry->id}}, $ballot;
		push @{$ballots_by_entry_panel{$ballot->entry->id."-".$ballot->panel->id}}, $ballot;
		push @{$ballots_by_judge_panel{$ballot->judge->id."-".$ballot->panel->id}}, $ballot;
		push @{$entry_ids_by_panel{$ballot->panel->id}}, $ballot->entry->id;
		push @{$judge_ids_by_panel{$ballot->panel->id}}, $ballot->judge->id;
		push @{$panel_ids_by_entry{$ballot->entry->id}}, $ballot->panel->id;

		$last_round{$ballot->entry->id} = $round_panel{$ballot->panel->id} if $last_round{$ballot->entry->id} < $round_panel{$ballot->panel->id};
	}

	my %dq_panel_threshold = ();

	foreach my $key (keys %dq_entry) { 
		foreach my $ballot (@{$ballots_by_entry{$key}}) { 
			my $rank;
			foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
					$rank = $value->value if $value->tag eq "rank";
				}
			$dq_panel_threshold{$ballot->panel->id."-".$ballot->judge->id} = $rank;
		}
	}

	if ($truncate_to_smallest) { 
		$truncate_to_smallest = $truncate;
		$truncate_to_smallest = "314159" unless $truncate_to_smallest;  #Ugly hack.  Sue me.
		foreach my $oround (@all_rounds) { 
			next unless $round->type eq "prelim";
			foreach my $panel (@{$panels_by_round{$round->id}}) { 
				my $size = scalar @{$entry_ids_by_panel{$panel->id}} if $entry_ids_by_panel{$panel->id};
				$truncate_to_smallest = $size if $truncate_to_smallest > $size;
			}
		}
	}

	if ($round && ($round->type eq "elim" || $round->type eq "final")) { 
		my @counted;
		foreach my $entry (@entries) { 
			next if $last_round{$entry->id} < $round->name;
			push (@counted, $entry);
		}
		@entries = @counted;
	}
	
	my %entry_tbs = ();
	my %tier_descs = ();
	my %tier_dir = ();

	foreach my $key (sort keys %tb_tiers) { 

		my $tier_desc;

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			$tier_dir{$key} = "down" if $tb->name eq "reciprocals" || $tb->name eq "judgepref" || $tb->name eq "points" || $tb->name eq "winloss" || $tb->name eq "opp_wins" || $tb->name eq "opp_points" || $tb->name eq "judgevar";
			$tier_dir{$key} = "up" if $tb->name eq "ranks" || $tb->name eq "coinflip" || $tb->name eq "competition" || $tb->name eq "rankinround";
			
			$tier_desc .= "+" if $tier_desc;
			$tier_desc .= "Rks" if $tb->name eq "ranks";
			$tier_desc .= "Pts" if $tb->name eq "points";
			$tier_desc .= "Rcp" if $tb->name eq "reciprocals";
			$tier_desc .= "JPr" if $tb->name eq "judgepref";
			$tier_desc .= "Rnd" if $tb->name eq "coinflip";
			$tier_desc .= "QC" if $tb->name eq "competition";
			$tier_desc .= "RRk" if $tb->name eq "rankinround";
			$tier_desc .= "Win" if $tb->name eq "winloss";
			$tier_desc .= "OWn" if $tb->name eq "opp_wins";
			$tier_desc .= "OPt" if $tb->name eq "opp_points";
			$tier_desc .= "JVr" if $tb->name eq "judgevar";
			$tier_desc .= " H/L" if $tb->highlow == 1;
			$tier_desc .= "2H/L" if $tb->highlow == 2;
			$tier_desc .= "-1H" if $tb->highlow == 3;
			$tier_desc .= "-1L" if $tb->highlow == 4;
		}

		$tier_descs{$key} = $tier_desc;

		foreach my $entry (@entries) { 

			my $tier_total;

			foreach my $tb (@{$tb_tiers{$key}}) { 

				my $name = $tb->name;
				my @rounds;

				foreach my $oround (@all_rounds) { 
					next if $oround->name > $round->name; #Avoid the future
					push (@rounds, $oround) if $oround->type eq $tb->count;
					push (@rounds, $oround) if $tb->count eq "all";
					push (@rounds, $round) if $round->type eq "elim" and $tb->count eq "last elim";
				}

				my $best;
				my $worst;
				my $total;
				my $nextbest;
				my $nextworst;

				if ($name eq "ranks") { 

					foreach my $this_round (@rounds) { 
					
						foreach my $panel (@{$panels_by_round{$this_round->id}}) { 
						
							foreach my $ballot (@{$ballots_by_entry_panel{$entry->id."-".$panel->id}}) { 

								my $rank;

								$noshows{$entry->id}++ if $ballot->noshow;
							
								foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
									$rank = $value->value if $value->tag eq "rank";
								}

								$rank-- if $dq_panel_threshold{$panel->id."-".$ballot->judge->id} > $rank;
								$rank++ if $ballot->tv && $mfl_time_violation;

								$rank = $truncate if $truncate &&  $rank > $truncate && $round->type eq "prelim";
								$rank = $truncate_to_smallest if $truncate_to_smallest && $rank > $truncate_to_smallest && $round->type eq "prelim";

								$total += $rank;


								if ($this_round->type eq "prelim") { 

									if ($rank >= $worst) { 
										$nextworst = $worst;
									}

									if ($rank > $worst) { 
										$worst = $rank;
									}

									if ($rank <= $best) { 
										$nextbest = $best;
									}

									if ($rank < $best || not defined $best) { 
										$best = $rank;
									}
								}
							}
						}
					}
								
					$total -= $best  if ($tb->highlow == 3 || $tb->highlow == 1 || $tb->highlow == 2);
					$total -= $worst if ($tb->highlow == 4 || $tb->highlow == 1 || $tb->highlow == 2);
					$total -= $nextbest  if ($tb->highlow == 2);
					$total -= $nextworst if ($tb->highlow == 2);



				} elsif ( $name eq "reciprocals") { 
					
					foreach my $this_round (@rounds) { 

						foreach my $panel (@{$panels_by_round{$this_round->id}}) { 

							foreach my $ballot (@{$ballots_by_entry_panel{$entry->id."-".$panel->id}}) { 

								my $rank;
							
								foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
									$rank = $value->value if $value->tag eq "rank";
								}

								$rank-- if $dq_panel_threshold{$panel->id."-".$ballot->judge->id} > $rank;
								$rank++ if $ballot->tv && $mfl_time_violation;
								$rank = $truncate if $truncate && $rank > $truncate && $round->type eq "prelim";

								if ($this_round->type eq "prelim"){ 

									if ($rank >= $worst) { 
										$nextworst = $worst;
									}

									if ($rank > $worst) { 
										$worst = $rank;
									}

									if ($rank <= $best) { 
										$nextbest = $best;
									}

									if ($rank < $best || not defined $best) { 
										$best = $rank;
									}
								}

								$total += (1/$rank) if $rank;

							}
						}

					}

					$total -= 1/$best  if $best && ($tb->highlow == 3 || $tb->highlow == 1 || $tb->highlow == 2);
					$total -= 1/$worst if $worst && ($tb->highlow == 4 || $tb->highlow == 1 || $tb->highlow == 2);
					$total -= 1/$nextbest  if $nextbest && ($tb->highlow == 2);
					$total -= 1/$nextworst if $nextworst &&  ($tb->highlow == 2);
					$total = sprintf "%.2f", $total;  #round to 2 decimal places;

				} elsif ( $name eq "points") { 

					foreach my $this_round (@rounds) { 

						foreach my $panel (@{$panels_by_round{$this_round->id}}) { 

							foreach my $ballot (@{$ballots_by_entry_panel{$entry->id."-".$panel->id}}) { 

								my $points;
							
								foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
									$points = $value->value if $value->tag eq "points";
								}

								$points-- if $dq_panel_threshold{$panel->id."-".$ballot->judge->id} > $points;
								$points++ if $ballot->tv && $mfl_time_violation;

								if ($this_round->type eq "prelim"){ 

									if ($points >= $worst) { 
										$nextworst = $worst;
									}

									if ($points > $worst) { 
										$worst = $points;
									}

									if ($points <= $best) { 
										$nextbest = $best;
									}

									if ($points < $best || not defined $best) { 
										$best = $points;
									}
								}

								$total += $points;

							}
						}
					}

					$total -= $best  if ($tb->highlow == 3 || $tb->highlow == 1 || $tb->highlow == 2);
					$total -= $worst if ($tb->highlow == 4 || $tb->highlow == 1 || $tb->highlow == 2);
					$total -= $nextbest  if ($tb->highlow == 2);
					$total -= $nextworst if ($tb->highlow == 2);

				} elsif ( $name eq "coinflip") { 

					# This is only semi random; product of the date epoch and
					# the random entry ID's last four digits.  But it will be
					# the same every time this function is run.

					my $random_seed = $entry->id * $tourn->start->epoch;
					$total = substr($random_seed, -8, -3);

				} elsif ( $name eq "judgepref") { 

					my @panel_ids;
					my $chosen_panel;
					
					PANEL:
					foreach my $panel (@{$panels_by_round{$round->id}}) {    #Only counts in the current round;
						@panel_ids = @{$entry_ids_by_panel{$panel->id}};
						next PANEL unless grep {$_ == $entry->id} @panel_ids;
						$chosen_panel = $panel;
					} 
					
					my %beseen = (); 
					@panel_ids = grep { ! $beseen{$_} ++ } @panel_ids;

					my $entry_string;
					foreach my $okey (sort keys %tb_tiers) { 
						next if $key == $okey;
						$entry_string .= "-" if $entry_string;
						$entry_string .= $entry_tbs{$entry->id."-".$okey};
					}

					my @ties;

					foreach my $entry_id (@panel_ids) { 
						next if $entry_id == $entry->id;
						my $test_string;
						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$test_string .= "-" if $test_string;
							$test_string .= $entry_tbs{$entry_id."-".$okey};
						}
						push(@ties, $entry_id) if $test_string eq $entry_string;
					}

					if (scalar @ties == 1) { 

						my $tie_id = shift @ties;

						my %judge_score = ();

						if ($chosen_panel && $entry) { 

							foreach my $ballot (@{$ballots_by_entry_panel{$entry->id."-".$chosen_panel->id}}) { 
								foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
									$judge_score{$ballot->judge->id} = $value->value if $value->tag eq "rank";
								}
							}
						
							foreach my $ballot (@{$ballots_by_entry_panel{$tie_id."-".$chosen_panel->id}}) { 

								foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
									$total++ if $value->tag eq "rank" &&  $judge_score{$ballot->judge->id} <  $value->value;
								}
							}
						}

					}
				} 

				$tier_total += $total * $tb->multiplier if $tb->multiplier;

			}

			$entry_tbs{$entry->id."-".$key} = $tier_total;

		}

	}

	foreach my $key (reverse sort keys %tb_tiers) { 
		@entries = sort { $entry_tbs{$a->id."-".$key} <=> $entry_tbs{$b->id."-".$key}  } @entries if $tier_dir{$key} eq "up";
		@entries = sort { $entry_tbs{$b->id."-".$key} <=> $entry_tbs{$a->id."-".$key}  } @entries if $tier_dir{$key} eq "down";
	}

	if ($equal_elims) { 

		my %panel_rank = ();

		foreach my $panel (@{$panels_by_round{$round->id}}) { 
			my @pan_entries = @{$entry_ids_by_panel{$panel->id}} if $entry_ids_by_panel{$panel->id};
			foreach my $key (reverse sort keys %tb_tiers) { 
				@pan_entries = sort { $entry_tbs{$a."-".$key} <=> $entry_tbs{$b."-".$key}  } @pan_entries if $tier_dir{$key} eq "up";
				@pan_entries = sort { $entry_tbs{$b."-".$key} <=> $entry_tbs{$a."-".$key}  } @pan_entries if $tier_dir{$key} eq "down";
			}

			my $count = 1;
			foreach my $pe (@pan_entries) { 
				$panel_rank{$pe} = $count++;
			}
		}
	
		@entries = sort { $panel_rank{$a->id} <=> $panel_rank{$b->id} } @entries;
	}

	@entries = sort { $a->placement <=> $b->placement } @entries;
	@entries = sort { $noshows{$a->id} <=> $noshows{$b->id} } @entries if $noshows_never_break;

	my $count;
	my %entry_by_place = ();
	
	my $last_string;
	my $delayed_count;

	foreach my $entry (@entries) { 

		my $tier_string;

		foreach my $key (sort keys %tb_tiers) { 
			$tier_string .= "-" if $tier_string;
			$tier_string .= $entry_tbs{$entry->id."-".$key};
		}

		if ($tier_string eq $last_string) { 
			$delayed_count++;
		} else {
			$count++;
			$count += $delayed_count;
			undef $delayed_count;
		}

		$last_string = $tier_string;
		push (@{$entry_by_place{$count}}, $entry);
	}

	return (\%entry_by_place, \%entry_tbs, \%tier_descs, \%noshows, \%tier_dir);

</%init>
