<%args>
	$circuit
	$tourn
	$event_id
	$number_of_panels => undef
	$manual_override => undef
</%args>
<%init>

#	Speech Paneling Method.  The ideas for this method and credit for showing
#	and explaining it to me go to David Cutler.

	use POSIX;

	$number_of_panels = $manual_override if $manual_override;
	my $event = Tab::Event->retrieve($event_id);

	# Get rid of any existing panels in the event if we're repaneling prelims.
	# The user has already been warned about this.	

	my @existing_panels = $event->panels(type => "prelim");

	foreach my $panel (@existing_panels) { 
		$panel->delete;		
	}	

	my @schools = sort { $b->event_count($event->id) <=> $a->event_count($event->id) } 
					$event->schools;

	my $number_of_entries = scalar $event->entries;
	my $number_of_speakers = ceil($number_of_entries / $number_of_panels);
	my $remainder = ($number_of_entries) - ($number_of_panels * ($number_of_speakers  -1));

	my @sorted_schools;
	my @rejected_schools;

	# What this does is form cohorts.  In each speaker level we grab
	# the largest school who can fit all on one row, and put them in this
	# row, until the row fills up.  That minimizes the number of times
	# kids from the same school will unnecessarily be on different rows,
	# and kids on the same row can never hit each other.

	foreach (1 .. $number_of_speakers) { 

		my $size = $number_of_panels unless $_ eq $number_of_speakers;
		$size = $remainder unless $size;
	
		unshift (@schools, @rejected_schools) if @rejected_schools;
		@rejected_schools = () if @rejected_schools;

		while ($size > 0) { 

			$size = 0 unless @schools;
			next unless @schools;

			my $test_school = shift @schools if @schools;

			if ($test_school->event_count($event->id) <= $size) { 
				push (@sorted_schools, $test_school);
				$size = $size - $test_school->event_count($event->id);
			} else { 
				push (@rejected_schools, $test_school);
			}


		}
	}

	my @entries;
	
	foreach my $school (@sorted_schools, @rejected_schools, @schools) { 

		my @school_entries = Tab::Entry->search( 
							school => $school->id, 
							event => $event->id, 
							dropped => 0, 
							waitlist => 0);

		push (@entries, @school_entries);

	} #end of foreach my school

	# Create an array of arrays of speakers, each array representing a
	# speaker cohort.

	my @original_cohort;

	# Now go through the competitors and assign them to cohorts in school
	# order.  

	my @new_entries = @entries;

	while (@entries) { 
	
		my @cohort;

		foreach (1 .. $number_of_panels) { 
			push (@cohort, shift @entries) if @entries;
		}

		# If we're left with stragglers at the end, then shove them around
		# as if they're just one big cohort.

		# Check if the number of remaining competitors is lower than the
		# number of panels in the event
		my $buffer = scalar @entries if scalar @entries < $number_of_panels;

		# If so, group them in with the last cohort so they are cycled
		# and shuffled and the same kids don't always end up in the big
		# rooms.
		push (@cohort, @entries) if $buffer;

		@entries = () if $buffer;

		push (@original_cohort, \@cohort);

	}

	@entries = @new_entries;
	undef @new_entries;

	# So now we have an array that will serve just fine for Round 1.
	# However, for other rounds, we have to do more to juggle things
	# around.

	# Get all prelim rounds
	my @rounds = Tab::Round->search( event => $event->id, type => "prelim");

	# Order the rounds since this ALWAYS breaks.

	my $round_counter;

	foreach my $round (sort {$a->timeslot->start->epoch <=> $b->timeslot->start->epoch} @rounds) { 

		my @speaker_cohorts;
		$round_counter++;

		my $counter;

		foreach my $coref (@original_cohort) { 

			$counter++;

			my @cohort = @{$coref};

			my $shift = ($round_counter - 1) * ($counter - 1);
			$shift = 1 if $shift == $number_of_panels; 		 #UGLY HACK

			my $buffer = scalar @cohort - $number_of_panels 
							if scalar @cohort > $number_of_panels;

			if (scalar @cohort == $shift && scalar @cohort > $number_of_panels) { 
				$shift = ($round_counter - 1);
			}

			foreach (1 .. $shift) { 

				my $move_it = shift @cohort;	# Take the person in the back.
				push(@cohort, $move_it); # Move them to the front.

			}	


			push (@speaker_cohorts, \@cohort);

		} #end of foreach coref 

		my $order = 0;
		my $letter = "A";

		my @panels;

		foreach my $coref (@speaker_cohorts) { 

			my @entries = @{$coref};
			my $panel;

			$order++;

			foreach my $comp (@entries) { 
				

				if ($order > 1) { 

					$panel = shift @panels;  #Take the next panel
					push (@panels, $panel);  #Put it at the end of the line

				} 

				next unless eval{$comp->id};  #Move forward if this is just a placeholder
				
				if ($order <= 1) { 

					# If this is the first time through, we need to create the
					# panels before we can shove anyone into them, yesno?
		
					$panel = Tab::Panel->create({
            			event       => $event->id,
            			round       => $round->id,             
						letter      => $letter,
						speechnumber => 1,
            			type        => "prelim",
	        		});

					$letter++;

					push (@panels, $panel);

				}	# end of if order is zero 

				my $ballot = Tab::Ballot->create({
   						panel => $panel->id,
	            		comp => $comp->id,             
						speakerorder => $order
        		});

			} #end foreach comp

		} #end of foreach cohort

		$round->preset(0);
		$round->update;

	} #end of foreach my $round

	my $err = $event->name ." has been panelled";
	$m->redirect("$Tab::url_prefix/panel/schemat_show.mhtml?event_id=".$event->id."&err=$err");



</%init>
