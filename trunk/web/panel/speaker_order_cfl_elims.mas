<%args>
	$round_id
	$debug => undef
	$noreturn => undef
</%args>
<%perl>

	my $round = Tab::Round->retrieve($round_id);

	my $last_round_name = $round->name -1;
	my @last_rounds = Tab::Round->search( event => $round->event->id, 
										   name => $last_round_name );
	my $last_round = shift @last_rounds;

	if ($last_round && $last_round->type eq "prelim") { 

		# This is octofinals, which means that speaker order is set entirely 
		# as the function of the total of their speaker orders in prelims

		foreach my $panel ($round->panels) { 

			my $order;

			foreach my $comp (sort {$b->order_total <=> $a->order_total} $panel->entries) {
				$order++;
				$comp->setorder($order,$panel->id);

			}
		}

	} else { 

		# In rounds after octofinals, it's a royal fucking pain in the ass.

		foreach my $panel ($round->panels) { 

			my $order;

			my @entries = $panel->entries;

			# Randomize them first. 
			@entries = randarray(@entries);

			# Then go through and try to push kids into different orders than
			# they were before.

			my %entries_can_speak = ();
			my %entries_chosen = ();
			my %comp_score = ();
			my %order_score = ();
			my @orders;

			foreach my $comp (@entries) { 

				my %has_spoken = ();

		       	foreach my $elim ($panel->event->rounds( type => "elim")) {
	           		next if $elim->id == $panel->round->id;

					my $spoke = $comp->order_by_round($elim);
					$has_spoken{$spoke}++;
				}
			
				foreach $order (1 .. (scalar @entries) ) { 

			
					push (@orders, $order);
					
					unless ($has_spoken{$order}) { 

						push (@{$entries_can_speak{$order}}, $comp);
						$comp_score{$comp->id}++;
						$order_score{$order}++;

					}
				}
			}

		    #uniq
		    my %seen = ();
		    @orders = grep { ! $seen{$_} ++ } @orders;

			@orders = sort {$order_score{$a} <=> $order_score{$b}} @orders;

			my %assigned = ();

			ORDER:
			foreach my $order (@orders) { 

				
				my @can_speak = @{$entries_can_speak{$order}} if $entries_can_speak{$order};

				my @available;

				foreach my $can (@can_speak) { 
					push (@available, $can) unless $assigned{$can->id};
				}

				if (@available) { 
				
					@available = sort{ $comp_score{$a->id} <=> $comp_score{$b->id} } @available;

					my $avail = shift @available;
				

					$avail->setorder($order, $panel->id);
					$assigned{$avail->id}++;

				} else { 
				

					if (@can_speak) { 
					

						# If someone else can speak in this position, see
						# if we can find an unassigned substitute for the
						# other position.

						my $success;

						foreach my $other (@can_speak) {

							next if $success;
							
							my $other_order = $other->speakerorder($panel);


							my @available_subs;

							foreach my $substitute (@{$entries_can_speak{$other_order}}) {
								push (@available_subs, $substitute) unless $assigned{$substitute->id};
							}

							if (@available_subs) { 
							

								my $sub = shift @available_subs;
								

								$other->setorder($order, $panel->id);
								$sub->setorder($other_order, $panel->id);

								$assigned{$sub->id}++;
								$assigned{$other->id}++;
								$success++;

							} else {


							}

						}

						unless ($success) { 

							# If no one can speak in this position, then
							# lucky idiot number 1 gets it.  
				
							my $screwme;

							foreach my $comp (@entries) {
								next if $assigned{$comp->id};
								$screwme = $comp;
							}

							$screwme->setorder($order, $panel->id);
							$assigned{$screwme->id}++;

						}

					} else {
	

						my $screwme;

						foreach my $comp (@entries) {
							next if $assigned{$comp->id};
							$screwme = $comp; 
						}

						$screwme->setorder($order, $panel->id);
						$assigned{$screwme->id}++;

					}

				}

			}

		}

	}

	$round->update;

	return unless $noreturn;

	$m->redirect("$Tab::url_prefix/panel/schemat_show.mhtml?event_id=".$round->event->id."&round_id=".$round_id);

	sub randarray {
        my @array = @_;
        my @rand = undef;
        my $seed = $#array + 1;
        my $randnum = int(rand($seed));
        $rand[$randnum] = shift(@array);
        while (1) {
                my $randnum = int(rand($seed));
                if ($rand[$randnum] eq undef) {
                        $rand[$randnum] = shift(@array);
                }
                last if ($#array == -1);
        }
        return @rand;
	}

</%perl>

