<%args>
	$round
	$debug => 0
</%args>
<%perl>

	#Works off of 4 basic global hash/arrays; this allows the functions to access the information they need
	#@entries is a global array of all entries in the event; %entry_by_id is a hash with record and SOP information in it
	#%precluded stores which teams can't hit each other; %bracket are the teams in the bracket being paired
	
	use POSIX;
	use List::Util 'shuffle';
	use Time::HiRes qw( time );
	
	# $round = Tab::Round->retrieve(49630); #just to test
	my $event = $round->event;
	my $pullup_method = $event->setting("pullup_method");

	our $oddround = 1;

	if (int($round->name/2) == $round->name/2) { $oddround= 0 };
	#Tab::debuglog("Odd round marker:".$oddround."");

	#use this round to seed
	my @round_dummy = Tab::Round->search( name=>$round->name-1, event=>$round->event );	
	#Tab::debuglog( "This round ID:".$round->id." this round name:".$round->name."");
	#Tab::debuglog( "round for seeding id:".$round_dummy[0]->id." round for seeding name:".$round_dummy[0]->name."");
	my $round_for_seeding = Tab::Round->retrieve( $round_dummy[0]->id );
	my $start = time(); 
		
	my @entries = $event->entries( unconfirmed => 0, waitlist => 0, dropped => 0, dq => 0 );

	# create a hash that stores a boolean value indicating whether teams can
	# debate each other, marked false for same school, hit before, etc.

	my %precluded; 
			
	#CREATE A 2-DIMENSIONAL HASH WITH ALL THE STUFF YOU NEED TO PAIR
	
	#STEP ONE: create hash and put in entry info
	my %entry_by_id;
	
	foreach my $entry (@entries) {
		$entry_by_id{$entry->id}{'code'} = $entry->code;
		$entry_by_id{$entry->id}{'school'} = $entry->school;
	}

	#STEP TWO: now load the number of wins

	my %winloss = $m->comp("/funclib/entry_wins.mas", event => $event, round => $round_for_seeding);

	foreach my $key ( keys %winloss ) {
		$entry_by_id{$key}{'wins'} = $winloss{$key}; 
	}
	
	#STEP THREE: assign the seeds
	my ($entries_ref, $tbs_ref, $desc_ref, $noshow_ref, $meh, $panrank_ref, $panletter_ref, $long_desc_ref) = $m->comp("/tabbing/results/order_entries.mas", long_names => 1, round => $round_for_seeding);

	my $x;
	foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) { 
		$x++;
		foreach my $entry_id (@{${$entries_ref}{$key}}) { 
			$entry_by_id{$entry_id}{'seed'}=$x;
		}
	}

	#STEP FOUR: calculate oppseeds
	
	#Start by pulling all the rounds
	my $rd_name=$round->name;
	Tab::Ballot->set_sql(pull_ballots => "
		select ballot.entry, ballot.panel, ballot.side
		from ballot, panel, round
		where ballot.panel=panel.id
		and panel.round=round.id
		and round.name < $rd_name
		and round.event = $event
		order by panel, entry
	");

	my @pairings = Tab::Ballot->search_pull_ballots;

	my $end = time();
	#Tab::debuglog( "load time:  ". printf("%.2f\n", $end - $start));
	
	# Log the pairings, just for grins	
	# foreach my $pairing (@pairings) {
	# 	#Tab::debuglog( "Panel: ".$pairing->panel." entry:".$pairing->entry." side=".$pairing->side."");
	# }
	
	#now loop through each team; this ALSO marks opponents as having debated so they don't hit in the future
	my $totopponents;
	my $totseeds;
	foreach my $entry (@entries) {

		#create an array that holds all the panels the team has been on; also store side due
		my @panels;
		foreach my $pairing (@pairings) {
			if ($pairing->entry == $entry->id) {
				 push (@panels, $pairing->panel);
				 if ($pairing->side == 1) { $entry_by_id{$pairing->entry}{'sidedue'} = 2; } #this resets every time, but works b/c the last one is the most recent
 				 if ($pairing->side == 2) { $entry_by_id{$pairing->entry}{'sidedue'} = 1; }
				 if ( $oddround == 1 ) { $entry_by_id{$pairing->entry}{'sidedue'} = 0; }
			}
		}
		$totseeds=0;
		$totopponents=0;	
		#now loop thorough all the pairings again, if the panel matches pull the opponent id and grab their seed	
		foreach my $pairing (@pairings) {
			foreach my $panel (@panels) {
				if ($pairing->panel == $panel and $pairing->entry != $entry->id) {
					$totopponents++;
					$totseeds += $entry_by_id{$pairing->entry}{'seed'};
					$precluded{$entry->id}{$pairing->entry} = 1; #mark as ineligible to hit b/c they debated before
				}
			}
		}
		$entry_by_id{$entry->id}{'oppseed'} = $totseeds/$totopponents  if $totopponents;
		$entry_by_id{$entry->id}{'SOP'} = $entry_by_id{$entry->id}{'oppseed'} + $entry_by_id{$entry->id}{'seed'} ;
	}

	#CREATE HASH THAT KNOWS WHO CAN DEBATE WHO; hit before constraint added above; hash declared at the very top, so we only need school conflicts

	for (my $x = 0; $x <= $#entries; $x++) {

		#pull hybrid school conflicts
		my @strikes = Tab::Strike->search( entry=> $entries[$x]->id, type => 'hybrid' );	

		for (my $y = $x + 1; $y <= $#entries; $y++) {

			#mark school conflicts
			if ($entries[$x]->school == $entries[$y]->school) { $precluded{$entries[$x]->id}{$entries[$y]->id} = 1; }
		
			foreach my $hybridconflict (@strikes) {
				if ($hybridconflict->school == $entries[$y]->school) { $precluded{$entries[$x]->id}{$entries[$y]->id} = 1; }
			}
		
		}
	}
	
	#problem child test
	$precluded{345142}{346787} = 1;

	# PAIR IT

	my %bracket; 
	
	#Figure out how many brackets to pair
	my $hibracket=-1;
	foreach my $key ( keys %entry_by_id ) {
		$hibracket = $entry_by_id{$key}{'wins'} if ($entry_by_id{$key}{'wins'} > $hibracket) ;
	}
	
	# Loop through the brackets, set them, then pair them creates a global hash
	# called %bracket that can be used by both functions

	$x = $hibracket;

	#Tab::debuglog( "Highest bracket is:".$hibracket."");
	while ($x > -1) {

		#Tab::debuglog( "<br><br>Now setting bracket $x");
		%bracket = setbracket($x, \%entry_by_id, \%bracket, \%precluded);
		my $nteams = keys %bracket;
		#Tab::debuglog( $nteams." total teams in the $x win bracket");

		#set SOP
		foreach my $key ( keys %bracket ) {
			$bracket{$key}{'SOP'} = $entry_by_id{$key}{'SOP'};
		}
		
		#initialize opponent to zero
		foreach my $key (sort {$entry_by_id{$a}->{'SOP'} <=> $entry_by_id{$b}->{'SOP'}} keys(%bracket)) {
			#Tab::debuglog( $entry_by_id{$key}{'code'}." wins:".$entry_by_id{$key}{'wins'}." SOP: ".$entry_by_id{$key}{'SOP'}." side due:".$entry_by_id{$key}{'sidedue'}."");
			$entry_by_id{$key}{'opponent'}=0;
		}

		#do the actual pairing
		my $outcome = pairbracket(\%entry_by_id, \%bracket);
		#Tab::debuglog( "Outcome is: ".$outcome."");

		if ($outcome eq "Fail") { 
			#Tab::debuglog("Failed") if $debug; 
			last; 
		}
		
		# pairbracket will return "Fail" if it can't do it
		# if it fails, 
		# (1) try the "just pair it" bracket option
		# (2) see if there's a pullup, and if there is, pull up someone else
		# (3) if there's not a pullup, pull up 2 more teams and try again
		# (4) if that doesn't work collapse it with the nearest bracket
		# (5) if that doesn't work, collapse all bracekts and try the "just pair it" option
		# (6) all else has failed, so kick it over to Palmer's thing that doesn't honor school and side constraints

		$x--;
	}

	# PAIRINGS ARE DONE, NOW MARK WHICH TEAM IS IN WHICH BRACKET

	my $bracket_value;
	foreach my $key ( keys %entry_by_id ) {
		$bracket_value = $entry_by_id{$key}{'wins'};

		if ($entry_by_id{$entry_by_id{$key}{'opponent'}}{'wins'} > $bracket_value ) { 
			$bracket_value = $entry_by_id{$entry_by_id{$key}{'opponent'}}{'wins'};
		}

		$bracket_value = 0 unless $bracket_value; 

		$entry_by_id{$key}{'bracket'} = $bracket_value;
		$entry_by_id{$entry_by_id{$key}{'opponent'}}{'bracket'} = $bracket_value;
	}	

	# SET SIDES IF IT'S AN ODD NUMBERED ROUND USING THE SERPENTINE THING

	my $switch = 0;
	my $oppside = 1;
	foreach my $key (sort {$entry_by_id{$a}->{'seed'} <=> $entry_by_id{$b}->{'seed'}} keys(%entry_by_id)) {
		if ($key > -1 and $entry_by_id{$key}{'sidedue'} == 0 and $entry_by_id{$key}{'opponent'} != -1 ) {
			$switch++;
			if ( $switch > 2 ) { $switch = 1; }
#			#Tab::debuglog( "Team: ".$key." ".$entry_by_id{$key}{'code'}." seed: ".$entry_by_id{$key}{'seed'}." side set to: ".$switch."");
			$entry_by_id{$key}{'sidedue'} = $switch;
			my $opponent = $entry_by_id{$key}{'opponent'};
			$oppside = 1;
			if ( $switch == 1 ) { $oppside = 2; }
			$entry_by_id{$opponent}{'sidedue'} = $oppside;
		}
	}

	#ERASE ANY CURRENT ROUND INFO AND SAVE
	erase_current_round($round);
	saveit($round, \%entry_by_id);
	
	sub setbracket {

		my $debug;
#		#Tab::debuglog( "in setbracket sub");
		
		#receives a bracket to fill, returns a hash with teams in that bracket
		
		my ($winbracket, $entry_by_id_ref, $bracket_ref, $precluded_ref) = @_;

		my %entry_by_id = %{$entry_by_id_ref};

		my %team;
		my $totalentries = keys %entry_by_id;	#total teams in the event; necessary to test for the last bracket	
		
		#populate the bracket
		foreach my $key ( keys %entry_by_id ) {
			if ($entry_by_id{$key}{'wins'} == $winbracket && $entry_by_id{$key}{'opponent'} == 0) { 
				$team{$key}{'side'} = $entry_by_id{$key}{'sidedue'}; 
				$entry_by_id{$key}{'opponent'} = -999;
			}
		}

		#loop and pull up until the bracket is even
		my $bracketeven = 0;
		my $brackettries = 0;
		while ( $bracketeven == 0 ) {
	
			#count the number of tries
			$brackettries++;
		
			#count total, aff, and neg teams	
			my $nteams = keys %team;
			my $aff = 0;
			my $neg = 0;
								
			foreach my $key ( keys %team ) {
				if ($team{$key}{'side'} == 1) { $aff++; }
				if ($team{$key}{'side'} == 2) { $neg++; }
			}
	
			#need to know how many teams have already been paired so you can see if this is the last bracket			
			my $paired_already = 0;			
			foreach my $key ( keys %entry_by_id ) {
				if ($entry_by_id{$key}{'opponent'} != 0) { $paired_already++; }
			}
			
			#test for an even bracket in an odd round
			if ($oddround == 1 and (int($nteams/2) == $nteams/2)) { $bracketeven = 1; }
			#test for an even bracekt in an even round
			if ($oddround == 0 and $aff == $neg) { $bracketeven = 1; }
			#test for this being the last bracket and needing a bye
#			#Tab::debuglog( "Total entries:".$totalentries." paired already:".$paired_already."");
			if ($paired_already == $totalentries) { $bracketeven = 1; }
			
#			#Tab::debuglog( "oddround:".$oddround." n teams:".$nteams." bracket even marker:".$bracketeven."");
			
			#exit if the bracket is even
			if ( $bracketeven == 1 ) { last; }
#			#Tab::debuglog( "Need to pull up");
			
			#kick into "make it work" mode if can't even the bracket
			if ( $brackettries > 100 ) { last; }
		
			#bracket not even, so pull up
			my $sidetopull = 0;

			$sidetopull = 1 if ($oddround == 0 && $aff < $neg);
			$sidetopull = 2 if ($oddround == 0 && $aff > $neg);

			my $pullup = pullup($sidetopull, $entry_by_id_ref, $bracket_ref, $precluded_ref);

#			#Tab::debuglog( "pulled up ". $pullup." ".$entry_by_id{$pullup}{'code'}."");
			$team{$pullup}{'side'} = $entry_by_id{$pullup}{'sidedue'} ;
			$entry_by_id{$pullup}{'opponent'} = -999; #stores a temporary opponent so they won't get pulled up again
#			#Tab::debuglog( "now this many teams in bracket:".keys %team; 
#			#Tab::debuglog( "");
		}

#		#Tab::debuglog( "exiting setbracket sub");		
		return %team;
	}

	sub pullup {

		my $debug;

		#Tab::debuglog( "Finding a pullup");
			
		#identifies which side you need to pull up; zero means either is OK
		my ($side, $entry_by_id_ref, $bracket_ref, $precluded_ref) = @_;
		my %entry_by_id = %{$entry_by_id_ref};
		
		foreach my $key (sort { $entry_by_id{$b}->{'wins'} <=> $entry_by_id{$a}->{'wins'} || $entry_by_id{$b}->{'oppseed'} <=> $entry_by_id{$a}->{'oppseed'} } keys(%entry_by_id)) {

			#make sure they are on the right side of the bracket
			my $sidematch=1;
			if ( $side>0 and $entry_by_id{$key}{'sidedue'} != $side ) { $sidematch = 0; }

			#make sure they can debate at least one team in the bracekt
			my $allconflicts = 0;
			foreach my $key2 ( keys %{$bracket_ref} ) {
				my $oktodebate=1;
				if ( hasconflict($key, $key2, $precluded_ref) == 1 ) { $oktodebate = 0; }
				if ( $side > 0 and $entry_by_id{$key}{'sidedue'} == ${$bracket_ref}{$key2}{'side'} ) { $oktodebate = 0;  }
				if ( $oktodebate == 1 ) { $allconflicts = 0; last; }
			}
			
			##Tab::debuglog( $entry_by_id{$key}{'code'}." Side match: ".$sidematch." opponent:".$entry_by_id{$key}{'opponent'}." all conflicted:".$allconflicts."");
			
			if ( $entry_by_id{$key}{'opponent'} == 0 and $sidematch == 1 and $allconflicts == 0 ) {
				return $key;
			}
			
		}
	}
	
	sub pairbracket {

		my $debug;

		my ($entry_by_id_ref, $bracket_ref) = @_;

		#do a normal bracket pairing
		
		hi_lo_bracket_pair($entry_by_id_ref, $bracket_ref);
			
		#make sure they're all paired, and if they are, bail
		
		if (unpaired($entry_by_id_ref, $bracket_ref) == 0) { return "Success"; }
		
		#not all teams have been paired, so see if there are an odd number of teams in the bracket
		#and there is only 1 unpaired team, and if so, assign a bye.  This should work so long as ONLY the last bracket 
		#has an odd number of teams, but I think the bracketmaker takes care of that
		
		my $nteams = keys %{$bracket_ref};	#figure out how many teams are in the bracket; you'll use this below	
						
		if (unpaired($entry_by_id_ref, $bracket_ref) == 1) {
			if ( int($nteams/2) != $nteams/2 ) {
				assignbye($entry_by_id_ref, $bracket_ref);
			}
		}

		if (unpaired($entry_by_id_ref, $bracket_ref) == 0) { return "Success"; }
		
		#Tab::debuglog( "In problem child");
						
		#Now you know it got to the last 2 teams and got stuck, so you have to roll back some existing pairings
		#Sort the bracket in reverse order, and unpair one debate at a time.  Then pair the problem team, and then
		#finish the bracket with a normal hi-lo pair.

		my $problemchild;
		foreach my $key ( sort { ${$bracket_ref}{$a}->{'SOP'} <=> ${$bracket_ref}{$b}->{'SOP'} } keys(%{$bracket_ref}) ) {
			if (${$entry_by_id_ref}{$key}{'opponent'} == 0) { 
				$problemchild = $key; last; 
			}
		}

		#Tab::debuglog( "Problem child is: ".${$entry_by_id_ref}{$problemchild}{'code'}."");
		
		my $n_bracket_tries = 0;
		my $n_problemchild_tries;
		
		while (unpaired($entry_by_id_ref, $bracket_ref) > 0 ) {
		
			$n_bracket_tries++; 
			return "Fail" if $n_bracket_tries > $nteams;

			while (${$entry_by_id_ref}{$problemchild}{'opponent'} == 0) {
			
				$n_problemchild_tries++; 
				return "Fail" if $n_problemchild_tries > $nteams;
				
				foreach my $key ( sort { ${$bracket_ref}{$b}->{'SOP'} <=> ${$bracket_ref}{$a}->{'SOP'} } keys(%{$bracket_ref}) ) {

					if ($key != $problemchild and ${$entry_by_id_ref}{$key}{'opponent'} > 0 ) {
						#Tab::debuglog( "Unpairing ".${$entry_by_id_ref}{$key}{'code'}." vs ".${$entry_by_id_ref}{${$entry_by_id_ref}{$key}{'opponent'}}{'code'}."");
		 				${$entry_by_id_ref}{${$entry_by_id_ref}{$key}{'opponent'}}{'opponent'} = 0;
						#Tab::debuglog(${$entry_by_id_ref}{${$entry_by_id_ref}{$key}{'opponent'}}{'code'}." opponent:".${$entry_by_id_ref}{${$entry_by_id_ref}{$key}{'opponent'}}{'opponent'});
						${$entry_by_id_ref}{$key}{'opponent'} = 0;
						#Tab::debuglog( " ".${$entry_by_id_ref}{$key}{'code'}. " opponent:".${$entry_by_id_ref}{$key}{'opponent'}."");
						last;
					}

				}
			
				hi_lo_single_pair($problemchild,$entry_by_id_ref,$bracket_ref);
			
			}
			
			hi_lo_bracket_pair($entry_by_id_ref, $bracket_ref);
		}
		
		#can only get here if unpaired now == 0
		return "Success";	
				
	}
	
	sub hi_lo_bracket_pair {

		my $debug;
	
		my ($entry_by_id_ref, $bracket_ref) = @_;	

		#start from the top of the {$bracket_ref}, and then go backwards up from the bottom of the {$bracket_ref} looking for an opponent who fits
		#pair if it's a match
		
		#major conceptual idea:  WHY do we start at the top of the AFF {$bracket_ref}?  What if the top of the NEG {$bracket_ref} is a lower seed?
		#In fact, why don't we do the high/low starting with the highest unpaired seed REGARDLESS of whether they are AFF or NEG?
		#The coding is easier AND its more consistent with the HiLo pair philosophy
		
		#for future reference: http://stackoverflow.com/questions/9660284/how-do-i-sort-a-hash-array-by-value-in-perl
		#lets you sort multiple ways, but you gotta put it in an array; see also Tie::SortHash
		
		foreach my $key ( sort { ${$bracket_ref}{$a}->{'SOP'} <=> ${$bracket_ref}{$b}->{'SOP'} } keys(%{$bracket_ref}) ) {

			#if it's an even round, only loop through the aff
			my $sidemarker = 1;
			if ($oddround == 0 and ${$bracket_ref}{$key}{'side'} == 2) { 
				$sidemarker = 0; 
			}

			#Tab::debuglog("Testing key $key in the hi-lo pairer");

			if ( ${$entry_by_id_ref}{$key}{'opponent'} == 0 and $sidemarker == 1 ) {

				#Tab::debuglog("Looking for an opponent for $key");

				foreach my $oppkey (sort { ${$bracket_ref}{$b}->{'SOP'} <=> ${$bracket_ref}{$a}->{'SOP'} } keys(%{$bracket_ref})) {
					Tab::debuglog( "Trying to pair ".${$entry_by_id_ref}{$key}{'code'}." vs ".${$entry_by_id_ref}{$oppkey}{'code'}." ");
					my $canpair = 1;

					if (${$entry_by_id_ref}{$oppkey}{'opponent'} != 0) {
						$canpair = 0; 
						Tab::debuglog( $oppkey." already paired.");
					}

					if (hasconflict($key, $oppkey) == 1) {
						$canpair = 0; 
						Tab::debuglog( $oppkey." teams have conflict.");
					}

					if ($key == $oppkey) {
						$canpair = 0; 
						Tab::debuglog( " Same team.");
					} 

					if ( $oddround == 0 and ${$bracket_ref}{$key}{'side'} == ${$bracket_ref}{$oppkey}{'side'} ) {
						$canpair = 0; 
						Tab::debuglog( ${$entry_by_id_ref}{$oppkey}{'code'}." sides don't match.");
					} 

					if ( $canpair == 1 ) {
						${$entry_by_id_ref}{$key}{'opponent'} = $oppkey;
						${$entry_by_id_ref}{$oppkey}{'opponent'} = $key;
						#Tab::debuglog( "WORKED!  Pairing ".${$entry_by_id_ref}{$key}{'code'}." vs ".${$entry_by_id_ref}{$oppkey}{'code'}."");
						last;
					}
				}
			}
		}
	
	}
	
	sub hi_lo_single_pair {
		my $debug;
	
		my ($team_to_pair, $entry_by_id_ref, $bracket_ref) = @_;	

		#Tab::debuglog( "Now trying to pair a single team in the {$bracket_ref}; team is ".${$entry_by_id_ref}{$team_to_pair}{'code'}."");
		
		foreach my $oppkey (sort { ${$bracket_ref}{$b}->{'SOP'} <=> ${$bracket_ref}{$a}->{'SOP'} } keys(%{$bracket_ref})) {
			my $canpair = 1;

			if (${$entry_by_id_ref}{$oppkey}{'opponent'} != 0) {
				$canpair = 0; 
				#Tab::debuglog( ${$entry_by_id_ref}{$oppkey}{'code'}." NO; already paired.");
			};
			if (hasconflict($team_to_pair, $oppkey) == 1) {
				$canpair = 0; 
				#Tab::debuglog( ${$entry_by_id_ref}{$oppkey}{'code'}." NO; teams have conflict.");
			}; 
			if ($team_to_pair == $oppkey) {
				$canpair = 0; 
				#Tab::debuglog( ${$entry_by_id_ref}{$oppkey}{'code'}." NO; is same team.");
			}; 
			if ( $oddround == 0 and ${$entry_by_id_ref}{$team_to_pair}{'sidedue'} == ${$entry_by_id_ref}{$oppkey}{'sidedue'} ) {
				$canpair = 0; 
				#Tab::debuglog( ${$entry_by_id_ref}{$oppkey}{'code'}." NO; sides don't match.");
			}; 

			if ( $canpair == 1 ) {
				${$entry_by_id_ref}{$team_to_pair}{'opponent'} = $oppkey;
				${$entry_by_id_ref}{$oppkey}{'opponent'} = $team_to_pair;
				#Tab::debuglog( "Pairing ".$team_to_pair." vs ".$oppkey."");
				last;
			}
		}
	
		return 0;
		
	}
	
	
	sub assignbye {
		my $debug;

		my ($entry_by_id_ref, $bracket_ref) = @_;
	
		foreach my $key (keys %{$bracket_ref} ) {
			#Tab::debuglog("Key is $key");

			if (${$entry_by_id_ref}{$key}{'opponent'} == 0) { 
				${$entry_by_id_ref}{$key}{'opponent'} = -1; 
			}

		}
	
	}
	
	sub unpaired {
		my $debug;

		my ($entry_by_id_ref, $bracket_ref) = @_;
	
		my $returnvalue = 0;
		
		foreach my $key ( keys %{$bracket_ref} ) {
			if (${$entry_by_id_ref}{$key}{'opponent'} == 0) { $returnvalue++; }
		}

		#Tab::debuglog( "unpaired: ".$returnvalue."");
		
		return $returnvalue;
		
	}

	sub hasconflict {
		my $debug;

		my ($team1, $team2, $precluded_ref) = @_;	
		my $returnvalue = 0;

		if (${$precluded_ref}{$team1}{$team2} == 1) { $returnvalue = 1; }

		if (${$precluded_ref}{$team2}{$team1} == 1) { $returnvalue = 1; }
		
		return $returnvalue;

	}
	
	sub erase_current_round {
		my $debug;

		my $round = shift;

		#Out with the old.	

		Tab::BallotValue->set_sql( delete_round => "
			delete ballot_value from ballot_value, ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
			and ballot.id = ballot_value.ballot
		");

		Tab::Ballot->set_sql( delete_round => "
			delete ballot from ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
		");

		Tab::Panel->set_sql( delete_round => "
			delete from panel where round = ?
		");

		Tab::BallotValue->sql_delete_round->execute($round->id);	
		Tab::Ballot->sql_delete_round->execute($round->id);
		Tab::Panel->sql_delete_round->execute($round->id);

	}
	
	sub saveit {

		my $debug;
		my ($round, $entry_by_id_ref) = @_;
		my %entry_by_id = %{$entry_by_id_ref};

		my $letter; my $pullup; my $position; my $bye; my $opponent;
		foreach my $key ( keys %entry_by_id ) {		

			if ( $key > -1 and ($entry_by_id{$key}{'sidedue'} == 1 or $entry_by_id{$key}{'opponent'} == -1 ) ) {

				#create the panel
				$letter++;
				$bye = 0; 
				if ( $entry_by_id{$key}{'opponent'} == 1 ) { $bye = 1; }
				my $panel = Tab::Panel->create({
					round   => $round->id,
					bye     => $bye,
					letter  => $letter,
					flight  => 1,
					bracket => $entry_by_id{$key}{'bracket'}
				});
				
				#save aff ballot
				$pullup = 0;
				$opponent = $entry_by_id{$key}{'opponent'};

				if ( $entry_by_id{$key}{'wins'} < $entry_by_id{$opponent}{'wins'} ) { $pullup = 1; }
				
				Tab::Ballot->create({
					panel        => $panel->id,
					judge        => 0,
					entry        => $key,
					side		 => 1,
					seed         => $entry_by_id{$key}{'seed'},
					pullup       => $pullup
				});
				
				#save neg ballot
				if ( $bye == 0 ) {
					$pullup = 0;
					if ( $entry_by_id{$key}{'wins'} > $entry_by_id{$opponent}{'wins'} ) { $pullup = 1; }
					Tab::Ballot->create({
						panel        => $panel->id,
						judge        => 0,
						entry        => $opponent,
						side		 => 2,
						seed         => $entry_by_id{$opponent}{'seed'},
						pullup       => $pullup
					});
				}
			}		
		}
	}

	print "<br>" if $debug;
		
	if ($debug) { 

		#printing the sorted seeds; just for debugging
		print "<div class='left huge'>";
		print "<table cellpadding='3' width='100%' class='tablesorter'>";
		print "<tr><td>key</td><td>code</td><td>school</td><td>wins</td><td>seed</td><td>oppseed</td><td>SOP</td><td>sideddue</td><td>opponent</td></tr>";

		foreach my $key (sort {$entry_by_id{$a}->{'seed'} <=> $entry_by_id{$b}->{'seed'}} keys(%entry_by_id)) {

			if ($key) {
				print "<tr>";
				print "<td>".$key."</td>";
				print "<td>".$entry_by_id{$key}{'code'}."</td>";
				print "<td>".$entry_by_id{$key}{'school'}."</td>";
				print "<td>".$entry_by_id{$key}{'wins'}."</td>";
				print "<td>".$entry_by_id{$key}{'seed'}."</td>";
				print "<td>".sprintf("%.3f", $entry_by_id{$key}{'oppseed'})."</td>";
				print "<td>".sprintf("%.3f", $entry_by_id{$key}{'SOP'})."</td>";
				print "<td>".$entry_by_id{$key}{'sidedue'}."</td>";
				print "<td>".$entry_by_id{$key}{'opponent'}." ".$entry_by_id{$entry_by_id{$key}{'opponent'}}{'code'}."</td>";
				print "</tr>";
			}
		}
		print "</table>";
		print "<br>";
		print "<table cellpadding='3' width='100%' class='tablesorter'>";
		print "<tr><td>Aff</td><td>W-Sd-SOP</td><td>Neg</td><td>W-Sd-SOP</td></tr>";
		foreach my $key (sort { $entry_by_id{$b}->{'bracket'} <=> $entry_by_id{$a}->{'bracket'} || $entry_by_id{$b}->{'SOP'} <=> $entry_by_id{$a}->{'SOP'} } keys(%entry_by_id)) {
			if ( $key and ($entry_by_id{$key}{'sidedue'} == 1 or $entry_by_id{$key}{'opponent'} == -1 ) ) {
				print "<tr>"; 
				print "<td>".$entry_by_id{$key}{'code'}."</td>";
				print "<td>".$entry_by_id{$key}{'wins'}."-".$entry_by_id{$key}{'seed'}."-".sprintf("%.3f", $entry_by_id{$key}{'SOP'})."</td>";
				my $key2 = $entry_by_id{$key}{'opponent'};
				print "<td>".$entry_by_id{$key2}{'code'}."</td>";
				print "<td>".$entry_by_id{$key2}{'wins'}."-".$entry_by_id{$key2}{'seed'}."-".sprintf("%.3f", $entry_by_id{$key2}{'SOP'})."</td>";
				print "</tr>";
			}
		}
		print "</table>";
	}

	print "All done and saved!<br>" if $debug;
	$end = time();
	print "<br>processing time:  "; printf("%.2f\n", $end - $start) if $debug;
	print "</div>" if $debug;

	undef $oddround;

</%perl>
