<%args>
	$circuit
	$tourn
	$event_id
	$number_of_panels => undef
	$manual_override => undef
	$debug => undef
</%args>
<%init>

#	Speech Paneling Method.  The ideas for this method and credit for showing
#	and explaining it to me go to David Cutler.

#	This file is solely for Diocesan based tournaments, of which there are
#	exactly 1: the National Catholic Forensic Circuit.

	use POSIX;

	$number_of_panels = $manual_override if $manual_override;
	my $event = Tab::Event->retrieve($event_id);

	# Get rid of any existing panels in the event if we're repaneling prelims.
	# The user has already been warned about this.	

	my @existing_panels = $event->panels(type => "prelim");

	foreach my $panel (@existing_panels) { 
		$panel->delete;		
	}

	my %entries_by_diocese = ();

	my @dioceses = $event->dioceses;

	foreach my $diocese (@dioceses) { 

		my @diocese_entries = $diocese->active_event_entries($event);
		push (@{$entries_by_diocese{$diocese->id}}, @diocese_entries);
		system "$Tab::logger Diocese ".$diocese->code." has ".scalar @diocese_entries." entries in this event" if $debug;

	}

	my $number_of_entries = scalar $event->entries( dropped => 0, waitlist => 0 );
	
	my $number_of_speakers = ceil($number_of_entries / $number_of_panels);
	my $remainder = ($number_of_entries) - ($number_of_panels * ($number_of_speakers - 1) );

	my @entries;

	system "$Tab::logger Number of entries: $number_of_entries" if $debug;
	system "$Tab::logger Number of speakers: $number_of_speakers" if $debug;
	system "$Tab::logger Number of dioceses: ".scalar @dioceses if $debug;

	# Create an array of arrays of speakers, each array representing a
	# speaker cohort.
	my @original_cohort;

	COHORT:
	foreach my $tick (1 .. $number_of_speakers) { 

		my $room_left = $number_of_panels;

		@dioceses = sort { (scalar @{$entries_by_diocese{$b->id}}) <=> (scalar @{$entries_by_diocese{$a->id}}) } @dioceses;

		my @cohort;
	
		foreach my $diocese (@dioceses) { 

			next unless @{$entries_by_diocese{$diocese->id}};
			next COHORT if $room_left < 1;

			my $room_left = $room_left - scalar @cohort;

			if (scalar @{$entries_by_diocese{$diocese->id}} > $number_of_panels) {

				while ($room_left > 0) { 
					push (@cohort, shift @{$entries_by_diocese{$diocese->id}});
					$room_left--;
				}
			}

			if (scalar @{$entries_by_diocese{$diocese->id}} <= $room_left) {
		
				push (@cohort, @{$entries_by_diocese{$diocese->id}});
				$room_left = $room_left - scalar @{$entries_by_diocese{$diocese->id}};
				@{$entries_by_diocese{$diocese->id}} = ();
			}

		}

		push (@original_cohort, \@cohort);

	} #end of foreach my diocese

	# So now we have an array that will serve just fine for Round 1.  However,
	# for other rounds, we have to do more to juggle things around.

	# We're going to use these later to smooth out the panels and iterate
	# through looking for better matches than we can supply at first.

	my %entries_by_panel = ();
	my %panels_by_round = ();

	# Get all prelim rounds

	my @rounds = Tab::Round->search( event => $event->id, type => "prelim");

	# Order the rounds since this ALWAYS breaks.

	my $round_counter;

	foreach my $round 
		(sort {$a->timeslot->start->epoch <=> $b->timeslot->start->epoch} @rounds) { 

		my @speaker_cohorts;
		$round_counter++;

		my $counter;

		foreach my $coref (@original_cohort) { 

			$counter++;

			my @cohort = @{$coref};

			my $shift = ($round_counter - 1) * ($counter - 1);
			$shift = 1 if $shift == $number_of_panels; 		 #UGLY HACK

			my $buffer = scalar @cohort - $number_of_panels 
							if scalar @cohort > $number_of_panels;

			if (scalar @cohort == $shift && scalar @cohort > $number_of_panels) { 
				$shift = ($round_counter - 1);
			}

			foreach (1 .. $shift) { 

				my $move_it = shift @cohort;	# Take the person in the back.
				push(@cohort, $move_it); # Move them to the front.

			}	

			push (@speaker_cohorts, \@cohort);

		} #end of foreach coref 

		my $order;
		my $letter = "A";

		my @panels;

		foreach my $coref (@speaker_cohorts) { 

			my @entries = @{$coref};
			my $panel;

			$order++;

			foreach my $comp (@entries) { 
				
				if ($order > 1) { 

					$panel = shift @panels;  #Take the next panel
					push (@panels, $panel);  #Put it at the end of the line

				} 

				next unless eval{$comp->id};  #Move forward if this is just a placeholder
				
				if ($order <= 1) { 

					# If this is the first time through, we need to create the
					# panels before we can shove anyone into them, yesno?
		
					$panel = Tab::Panel->create({
            			event       => $event->id,
            			round       => $round->id,             
						letter      => $letter,
            			type        => "prelim",
	        		});

					$letter++;

					push (@panels, $panel);
					push (@{$panels_by_round{$round->id}}, $panel);

				}	# end of if order is zero 


				push (@{$entries_by_panel{$panel->id}}, $comp);

			}

		}

		$round->preset(0);
		$round->update;

	} #end of foreach my $round

	my %comp_hits = ();
	my %comp_diocese_id = ();

	foreach my $panel_id (keys %entries_by_panel) { 
		
		foreach my $c1 ( @{$entries_by_panel{$panel_id}} )  { 

			$comp_diocese_id{$c1->id} = $c1->region->id;

			#Double reverse loop-fu!
			foreach my $c2 ( @{$entries_by_panel{$panel_id}} )  { 

				my $key = $c1->id."-".$c2->id;
				$comp_hits{$key}++;

			}
		}
	}

	# In theory that should have worked and found a quasi-optimal solution.
	# In practice there's not a chance in hell. 

	foreach my $round (@rounds) { 

		foreach my $panel (@{$panels_by_round{$round->id}}) { 
				
			my $order = 1;

			foreach my $comp (@{$entries_by_panel{$panel->id}}) { 
		
				my $ballot = Tab::Ballot->create({
   					panel => $panel->id,
   	   				comp => $comp->id,             
					speakerorder => $order,
					speechnumber => 1
  				});

				$order++;

			}
		
		}

	}

#   $m->redirect("$Tab::url_prefix/panel/smooth_panels.mas?event_id=".$event->id);

	my $err = $event->name ." has been panelled";
	$m->redirect("$Tab::url_prefix/panel/schemat_show.mhtml?event_id=".$event->id."&err=$err");

</%init>
