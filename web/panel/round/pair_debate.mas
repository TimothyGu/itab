<%args>
	$round
	$debug => 0
</%args>
<%perl>

	use POSIX;
	use Time::HiRes qw( time );
		
	my $event = $round->event;
	my $pullup_method = $event->setting("pullup_method");
	my $powermatch_method = $event->setting("powermatch");

	$m->print("Pairing using ".$powermatch_method." method for power-matching and ".$pullup_method." for pullups<br>");	
		
	#erase any current round
	erase_current_round($round);
		
	my $oddround = 0;
	$oddround++ if ($round->name % 2); 
	$oddround = 0 if $event->setting("no_side_constraints");

	Tab::debuglog("Odd round is $oddround");

	# use this round to seed

	my @round_dummy = Tab::Round->search( name=>$round->name-1, event=>$round->event );	

#	print "This round ID:".$round->id." this round name:".$round->name."<br>";
#	print "round for seeding id:".$round_dummy[0]->id." round for seeding name:".$round_dummy[0]->name."<br>";

	my $round_for_seeding = Tab::Round->retrieve( $round_dummy[0]->id );
	my $start = time(); 
		
	my ($entry_by_id_hash_ref, $precluded_hash_ref) = $m->comp("/funclib/make_pairing_hash.mas", round_id => $round->id);			

	my %entry_by_id = %{$entry_by_id_hash_ref};
	my %precluded = %{$precluded_hash_ref};

	my $end = time();

	my $crap = keys %entry_by_id; 
	Tab::debuglog("Total teams to pair: $crap");
	
	# PAIR IT

	my %bracket; 
	
	#Figure out how many brackets to pair
	my $hibracket=-1;
	foreach my $key ( keys %entry_by_id ) {
		$hibracket = $entry_by_id{$key}{'wins'} if ($entry_by_id{$key}{'wins'} > $hibracket) ;
	}
	
	# Loop through the brackets, set them, then pair them creates a global hash
	# called %bracket that can be used by both functions

	my $x = $hibracket;

	#Tab::debuglog( "Highest bracket is:".$hibracket."");
	while ($x > -1) {

#		print "Now setting bracket $x <br>";
		%bracket = setbracket($oddround, $x, $pullup_method, \%entry_by_id, \%bracket, \%precluded);

		my $nteams;
		#set SOP and seed for sorting
		foreach my $key ( keys %bracket ) {
			$bracket{$key}{'SOP'} = $entry_by_id{$key}{'SOP'};
			$bracket{$key}{'seed'} = $entry_by_id{$key}{'seed'};
			$bracket{$key}{'seed'} = $entry_by_id{$key}{'seed_nowins'};
			$bracket{$key}{'id'}=$key;
			$nteams++;
		}
#		print $nteams." total teams in the $x win bracket<br>";
		
		#initialize opponent to zero
		foreach my $key (sort {$entry_by_id{$a}->{'SOP'} <=> $entry_by_id{$b}->{'SOP'}} keys(%bracket)) {
			Tab::debuglog( $entry_by_id{$key}{'code'}." wins:".$entry_by_id{$key}{'wins'}." SOP: ".$entry_by_id{$key}{'SOP'}." side due:".$entry_by_id{$key}{'sidedue'}."");
			$entry_by_id{$key}{'opponent'}=0;
		}

		#do the actual pairing
		my $outcome = pairbracket($oddround, $powermatch_method, \%entry_by_id, \%bracket, \%precluded);
#		Tab::debuglog( "Outcome is: ".$outcome."");

#		if ($outcome eq "Fail") { 
#			print("Failed<br>");
#			last; 
#		}
		
		# pairbracket will return "Fail" if it can't do it
		# if it fails, 
		# (1) try the "just pair it" bracket option

		if ($outcome eq "Fail") { 
#			print "Failed -- just making it work.<br>";
			Tab::debuglog("Failed") if $debug; 
			$outcome = justmakeitwork(\%bracket, \%entry_by_id, $oddround);
			if ($outcome eq "Fail") { 
				last; 
			}
		}

		# (2) see if there's a pullup, and if there is, pull up someone else
		# (3) if there's not a pullup, pull up 2 more teams and try again
		# (4) if that doesn't work collapse it with the nearest bracket
		# (5) if that doesn't work, collapse all bracekts and try the "just pair it" option
		# (6) all else has failed, so kick it over to Palmer's thing that doesn't honor school and side constraints

		$x--;
	}

	# PAIRINGS ARE DONE, NOW MARK WHICH TEAM IS IN WHICH BRACKET

	my $bracket_value;
	foreach my $key ( keys %entry_by_id ) {
		$bracket_value = $entry_by_id{$key}{'wins'};

		if ($entry_by_id{$entry_by_id{$key}{'opponent'}}{'wins'} > $bracket_value ) { 
			$bracket_value = $entry_by_id{$entry_by_id{$key}{'opponent'}}{'wins'};
		}

		$bracket_value = 0 unless $bracket_value; 

		$entry_by_id{$key}{'bracket'} = $bracket_value;
		$entry_by_id{$entry_by_id{$key}{'opponent'}}{'bracket'} = $bracket_value;
	}	

	# SET SIDES IF IT'S AN ODD NUMBERED ROUND USING THE SERPENTINE THING

	if ($oddround == 1) {
#		print "Snaking sides for the odd round<br>";
		#set to zero unless bye
		foreach my $key ( keys %entry_by_id ) {
			if ($entry_by_id{$key}{'opponent'} > -1 ) { $entry_by_id{$key}{'sidedue'} = 0; }
		}
		my $switch = 0;
		my $oppside = 1;
		foreach my $key (sort {$entry_by_id{$a}->{'seed'} <=> $entry_by_id{$b}->{'seed'}} keys(%entry_by_id)) {
			if ($key > -1 and $entry_by_id{$key}{'sidedue'} == 0 and $entry_by_id{$key}{'opponent'} != -1 ) {
				$switch++;
				if ( $switch > 2 ) { $switch = 1; }
#				print "Team: ".$key." ".$entry_by_id{$key}{'code'}." seed: ".$entry_by_id{$key}{'seed'}." side set to: ".$switch."<br>";
				$entry_by_id{$key}{'sidedue'} = $switch;
				my $opponent = $entry_by_id{$key}{'opponent'};
				$oppside = 1;
				if ( $switch == 1 ) { $oppside = 2; }
				$entry_by_id{$opponent}{'sidedue'} = $oppside;
			}
		}
	}


	#SAVE
	$end = time();
	print "Total pairing time before save:  "; printf("%.2f\n", $end - $start); print "<br>";

	saveit($round, \%entry_by_id);
	
	sub setbracket {

		my $debug;
#		#Tab::debuglog( "in setbracket sub");
		
		#receives a bracket to fill, returns a hash with teams in that bracket
		
		my ($oddround, $winbracket, $pullup_method, $entry_by_id_ref, $bracket_ref, $precluded_ref) = @_;

#		print " odd round:".$oddround." winbracket=".$winbracket."<br>";
		my %entry_by_id = %{$entry_by_id_ref};
#		print"Starting with this many teams in entry_by_id:".(keys %entry_by_id)."<br>"; 
		
		my %team;
		my $totalentries = keys %entry_by_id;	#total teams in the event; necessary to test for the last bracket	
		
		#populate the bracket
		foreach my $key ( keys %entry_by_id ) {
			#print $entry_by_id{$key}{'code'}." has ".$entry_by_id{$key}{'wins'}." wins and current opponent is ".$entry_by_id{$key}{'opponent'};
			if ($entry_by_id{$key}{'wins'} == $winbracket && $entry_by_id{$key}{'opponent'} == 0) { 
				$team{$key}{'side'} = $entry_by_id{$key}{'sidedue'}; 
				$entry_by_id{$key}{'opponent'} = -999;
			}
		}

#		print"Starting with this many teams in bracket:".(keys %team)."<br>"; 


		#loop and pull up until the bracket is even
		my $bracketeven = 0;
		my $brackettries = 0;
		while ( $bracketeven == 0 ) {
	
			#count the number of tries
			$brackettries++;
		
			#count total, aff, and neg teams	
			my $nteams = keys %team;
			my $aff = 0;
			my $neg = 0;
								
			foreach my $key ( keys %team ) {
				if ($team{$key}{'side'} == 1) { $aff++; }
				if ($team{$key}{'side'} == 2) { $neg++; }
			}
	
			#need to know how many teams have already been paired so you can see if this is the last bracket			
			my $paired_already = 0;			
			foreach my $key ( keys %entry_by_id ) {
				if ($entry_by_id{$key}{'opponent'} != 0) { $paired_already++; }
			}
			
			#test for an even bracket in an odd round
			if ($oddround == 1 and (int($nteams/2) == $nteams/2)) { $bracketeven = 1; }

			#test for an even bracekt in an even round
			if ($oddround == 0 and $aff == $neg) { $bracketeven = 1; }

			#test for this being the last bracket and needing a bye
#			#Tab::debuglog( "Total entries:".$totalentries." paired already:".$paired_already."");
			if ($paired_already == $totalentries) { $bracketeven = 1; }
			
			Tab::debuglog( "oddround:".$oddround." n teams:".$nteams." bracket even marker:".$bracketeven."");
			
			#exit if the bracket is even
			if ( $bracketeven == 1 ) { last; }
#			#Tab::debuglog( "Need to pull up");
			
			#kick into "make it work" mode if can't even the bracket
			if ( $brackettries > 100 ) { last; }
		
			#bracket not even, so pull up
			my $sidetopull = 0;

			$sidetopull = 1 if ($oddround == 0 && $aff < $neg);
			$sidetopull = 2 if ($oddround == 0 && $aff > $neg);

			my $pullup = pullup($sidetopull, $pullup_method, $entry_by_id_ref, $bracket_ref, $precluded_ref);

#			print "pulled up ". $pullup." ".$entry_by_id{$pullup}{'code'}."<br>";
			$team{$pullup}{'side'} = $entry_by_id{$pullup}{'sidedue'} ;
			$entry_by_id{$pullup}{'opponent'} = -999; #stores a temporary opponent so they won't get pulled up again
#			print"now this many teams in bracket:".(keys %team)."<br>"; 
#			#Tab::debuglog( "");
		}

#		print "exiting setbracket sub<br>";		
		return %team;
	}

	sub pullup {

		my $debug;

#		print "Finding a pullup";
			
		#identifies which side you need to pull up; zero means either is OK
		my ($side, $pullup_method, $entry_by_id_ref, $bracket_ref, $precluded_ref) = @_;
		my %entry_by_id = %{$entry_by_id_ref};
		
		my @pullup;
		my @opp_bracket; 

		
		if ($pullup_method eq "sop") {
	
			@opp_bracket = sort { $entry_by_id{$b}->{'wins'} <=> $entry_by_id{$a}->{'wins'} || $entry_by_id{$b}->{'oppseed'} <=> $entry_by_id{$a}->{'oppseed'} || $entry_by_id{$b}->{'seed'} <=> $entry_by_id{$a}->{'seed'}} keys(%entry_by_id);
	
		} else {
	
		@opp_bracket = sort { $entry_by_id{$b}->{'wins'} <=> $entry_by_id{$a}->{'wins'} || $entry_by_id{$a}->{'opp_wins'} <=> $entry_by_id{$b}->{'opp_wins'} || $entry_by_id{$b}->{'seed'} <=> $entry_by_id{$a}->{'seed'}} keys(%entry_by_id);
	
		}
		
		foreach my $pullup ( @pullup) {

			my $key = ${$bracket_ref}{$pullup}{'id'};
			
			#make sure they are on the right side of the bracket
			my $sidematch=1;
			if ( $side>0 and $entry_by_id{$key}{'sidedue'} != $side ) { $sidematch = 0; }

			#make sure they can debate at least one team in the bracekt
			my $allconflicts = 0;
			foreach my $key2 ( keys %{$bracket_ref} ) {
				my $oktodebate=1;
				if ( hasconflict($key, $key2, $precluded_ref) == 1 ) { $oktodebate = 0; }
				if ( $side > 0 and $entry_by_id{$key}{'sidedue'} == ${$bracket_ref}{$key2}{'side'} ) { $oktodebate = 0;  }
				if ( $oktodebate == 1 ) { $allconflicts = 0; last; }
			}
			
#			print $entry_by_id{$key}{'code'}." Side match: ".$sidematch." opponent:".$entry_by_id{$key}{'opponent'}." all conflicted:".$allconflicts."<br>";
			
			if ( $entry_by_id{$key}{'opponent'} == 0 and $sidematch == 1 and $allconflicts == 0 ) {
				return $key;
			}
			
		}
	}
	
	sub pairbracket {

		my $debug;

		my ($oddround, $powermatch_method, $entry_by_id_ref, $bracket_ref, $precluded_ref) = @_;

		#do a normal bracket pairing
		
		my $nteams = keys %{$bracket_ref};	#figure out how many teams are in the bracket; you'll use this below	

		hi_lo_bracket_pair($oddround, $powermatch_method, $entry_by_id_ref, $bracket_ref, $precluded_ref);
			
		#make sure they're all paired, and if they are, bail
		
		my $unpaired_teams = unpaired($entry_by_id_ref, $bracket_ref);
		
		if ($unpaired_teams == 0) { return "Success"; }
		
#		print $unpaired_teams." teams are still unpaired<br>";
		
		#not all teams have been paired, so see if there are an odd number of teams in the bracket
		#and there is only 1 unpaired team, and if so, assign a bye.  This should work so long as ONLY the last bracket 
		#has an odd number of teams, but I think the bracketmaker takes care of that
		
								
		if (unpaired($entry_by_id_ref, $bracket_ref) == 1) {
			if ( int($nteams/2) != $nteams/2 ) {
				assignbye($entry_by_id_ref, $bracket_ref);
			}
		}

		if (unpaired($entry_by_id_ref, $bracket_ref) == 0) { return "Success"; }
		
		#Now you know it got to the last 2 teams and got stuck, so you have to roll back some existing pairings
		#Sort the bracket in reverse order, and unpair one debate at a time.  Then pair the problem team, and then
		#finish the bracket with a normal hi-lo pair.

		my $problemchild;
		foreach my $key ( sort { ${$bracket_ref}{$a}->{'SOP'} <=> ${$bracket_ref}{$b}->{'SOP'} } keys(%{$bracket_ref}) ) {
			if (${$entry_by_id_ref}{$key}{'opponent'} == 0) { 
				$problemchild = $key; last; 
			}
		}

#		print "Problem child is: ".${$entry_by_id_ref}{$problemchild}{'code'}." ".$problemchild."<br>";
		
		my $n_bracket_tries = 0;
		my $n_problemchild_tries;
		
		my $ok_to_start = 0;
		
		foreach my $key ( sort { ${$bracket_ref}{$b}->{'SOP'} <=> ${$bracket_ref}{$a}->{'SOP'} } keys(%{$bracket_ref}) ) {
			
#			print "tyring to unpair:".${$entry_by_id_ref}{$key}{'code'};
#			print " ok_to_start marker:".$ok_to_start."<br>";

			if ( $problemchild == $key ){ $ok_to_start = 1; }

			if ($key != $problemchild and ${$entry_by_id_ref}{$key}{'opponent'} > 0 and $ok_to_start == 1 ) {
#				print "Unpairing ".${$entry_by_id_ref}{$key}{'code'}." vs ".${$entry_by_id_ref}{${$entry_by_id_ref}{$key}{'opponent'}}{'code'}."<br>";

 				${$entry_by_id_ref}{${$entry_by_id_ref}{$key}{'opponent'}}{'opponent'} = 0;
				${$entry_by_id_ref}{$key}{'opponent'} = 0;
				
				#now pair the problem child		
				hi_lo_single_pair($oddround, $powermatch_method, $problemchild, $entry_by_id_ref, $bracket_ref, $precluded_ref);
				#now try to finish the bracket via hi-lo
				hi_lo_bracket_pair($oddround, $powermatch_method, $entry_by_id_ref, $bracket_ref, $precluded_ref);
				#if it worked, bail, and otherwise loop back and undo the next pairing
				if (unpaired($entry_by_id_ref, $bracket_ref) == 0) { last; }			
			}
		
		}
			
		if (unpaired($entry_by_id_ref, $bracket_ref) == 0) { return "Success"; }			
		return "Fail";	
				
	}
	
	sub hi_lo_bracket_pair {

		my $debug;
	
		my ($oddround, $powermatch_method, $entry_by_id_ref, $bracket_ref, $precluded_ref) = @_;	

		#start from the top of the {$bracket_ref}, and then go backwards up from the bottom of the {$bracket_ref} looking for an opponent who fits
		#pair if it's a match
		
		#major conceptual idea:  WHY do we start at the top of the AFF {$bracket_ref}?  What if the top of the NEG {$bracket_ref} is a lower seed?
		#In fact, why don't we do the high/low starting with the highest unpaired seed REGARDLESS of whether they are AFF or NEG?
		#The coding is easier AND its more consistent with the HiLo pair philosophy
		
		#for future reference:  see also Tie::SortHash

		#foreach my $key ( sort { ${$bracket_ref}{$a}->{'SOP'} <=> ${$bracket_ref}{$b}->{'SOP'} || ${$bracket_ref}{$a}->{'seed'} <=> ${$bracket_ref}{$b}->{'seed'} } keys(%{$bracket_ref}) ) {

		my @sorted_bracket;
		my @opp_bracket;

		if ($powermatch_method eq "sop") {
	
			@sorted_bracket = sort { ${$bracket_ref}{$a}->{'SOP'} <=> ${$bracket_ref}{$b}->{'SOP'} || ${$bracket_ref}{$a}->{'seed'} <=> ${$bracket_ref}{$b}->{'seed'} } keys(%{$bracket_ref});

			@opp_bracket = sort { ${$bracket_ref}{$b}->{'SOP'} <=> ${$bracket_ref}{$a}->{'SOP'} || ${$bracket_ref}{$b}->{'seed'} <=> ${$bracket_ref}{$a}->{'seed'} } keys(%{$bracket_ref});
	
		}
	
		if ($powermatch_method eq "seed") {
	
			@sorted_bracket = sort { ${$bracket_ref}{$a}->{'seed_nowins'} <=> ${$bracket_ref}{$b}->{'seed'} } keys(%{$bracket_ref});

			@opp_bracket = sort { ${$bracket_ref}{$b}->{'seed_nowins'} <=> ${$bracket_ref}{$a}->{'seed'} } keys(%{$bracket_ref});
	
		}
	
					
		foreach my $bracket_member ( @sorted_bracket ) {

			my $key = ${$bracket_ref}{$bracket_member}{'id'};
			
			#if it's an even round, only loop through the aff
			my $sidemarker = 1;
			if ($oddround == 0 and ${$bracket_ref}{$key}{'side'} == 2) { 
				$sidemarker = 0; 
			}

#			print "key:".$key." opponent:".${$entry_by_id_ref}{$key}{'opponent'}." sidemarker:".$sidemarker."<br>";
			 	
			if ( ${$entry_by_id_ref}{$key}{'opponent'} == 0 and $sidemarker == 1 and $key > 0) {

				foreach my $opp_bracket_member ( @opp_bracket ) {
				
					my $oppkey=${$bracket_ref}{$opp_bracket_member}{'id'};

					my $canpair = 1;

					if (${$entry_by_id_ref}{$oppkey}{'opponent'} != 0) {
						$canpair = 0; 
#						print $oppkey." already paired<br>";
					}

					if (hasconflict($key, $oppkey, $precluded_ref) == 1) {
						$canpair = 0; 
#						print $oppkey." teams have conflict<br>";
					}

					if ($key == $oppkey) {
						$canpair = 0; 
#						print " Same team.<br>";
					} 

					if ( $oddround == 0 and ${$bracket_ref}{$key}{'side'} == ${$bracket_ref}{$oppkey}{'side'} ) {
						$canpair = 0; 
#						print ${$entry_by_id_ref}{$oppkey}{'code'}." sides don't match<br>";
					} 

					if ( $canpair == 1 ) {
						${$entry_by_id_ref}{$key}{'opponent'} = $oppkey;
						${$entry_by_id_ref}{$oppkey}{'opponent'} = $key;
#						print "WORKED!  Pairing ".${$entry_by_id_ref}{$key}{'code'}." vs ".${$entry_by_id_ref}{$oppkey}{'code'}."<br><br>";
						last;
					}
				}
			}
		}
	
	}

	sub hi_lo_single_pair {
		my $debug;
	
		my ($oddround, $powermatch_method, $team_to_pair, $entry_by_id_ref, $bracket_ref, $precluded_ref) = @_;	
		
		#Tab::debuglog( "Now trying to pair a single team in the {$bracket_ref}; team is ".${$entry_by_id_ref}{$team_to_pair}{'code'}."");
		
		foreach my $oppkey (sort { ${$bracket_ref}{$b}->{'SOP'} <=> ${$bracket_ref}{$a}->{'SOP'} || ${$bracket_ref}{$b}->{'seed'} <=> ${$bracket_ref}{$a}->{'seed'} } keys(%{$bracket_ref})) {
			my $canpair = 1;

			if (${$entry_by_id_ref}{$oppkey}{'opponent'} != 0) {
				$canpair = 0; 
				#Tab::debuglog( ${$entry_by_id_ref}{$oppkey}{'code'}." NO; already paired.");
			};
			if (hasconflict($team_to_pair, $oppkey, $precluded_ref) == 1) {
				$canpair = 0; 
				#Tab::debuglog( ${$entry_by_id_ref}{$oppkey}{'code'}." NO; teams have conflict.");
			}; 
			if ($team_to_pair == $oppkey) {
				$canpair = 0; 
				#Tab::debuglog( ${$entry_by_id_ref}{$oppkey}{'code'}." NO; is same team.");
			}; 
			if ( $oddround == 0 and ${$entry_by_id_ref}{$team_to_pair}{'sidedue'} == ${$entry_by_id_ref}{$oppkey}{'sidedue'} ) {
				$canpair = 0; 
				#Tab::debuglog( ${$entry_by_id_ref}{$oppkey}{'code'}." NO; sides don't match.");
			}; 

			if ( $canpair == 1 ) {
				${$entry_by_id_ref}{$team_to_pair}{'opponent'} = $oppkey;
				${$entry_by_id_ref}{$oppkey}{'opponent'} = $team_to_pair;
				#Tab::debuglog( "Pairing ".$team_to_pair." vs ".$oppkey."");
				last;
			}
		}
	
		return 0;
		
	}
	
	
	sub assignbye {
		my $debug;

		my ($entry_by_id_ref, $bracket_ref) = @_;
	
		foreach my $key (keys %{$bracket_ref} ) {
			#Tab::debuglog("Key is $key");

			if (${$entry_by_id_ref}{$key}{'opponent'} == 0) { 
				${$entry_by_id_ref}{$key}{'opponent'} = -1; 
			}

		}
	
	}
	
	sub unpaired {
		my $debug;

		my ($entry_by_id_ref, $bracket_ref) = @_;
	
		my $returnvalue = 0;
		
		foreach my $key ( keys %{$bracket_ref} ) {
			if (${$entry_by_id_ref}{$key}{'opponent'} == 0) { $returnvalue++; }
		}

		#Tab::debuglog( "unpaired: ".$returnvalue."");
		
		return $returnvalue;
		
	}

	sub hasconflict {

		my ($team1, $team2, $precluded_ref) = @_;	
		my $returnvalue = 0;

		if (${$precluded_ref}{$team1}{$team2} == 1) { $returnvalue = 1; }

		if (${$precluded_ref}{$team2}{$team1} == 1) { $returnvalue = 1; }
		
#		if ( $returnvalue == 1) { print "conflict betweeen ".$team1." and ".$team2."<br>"; }
		
		return $returnvalue;

	}
	
	sub erase_current_round {
		my $debug;

		my $round = shift;

		#Out with the old.	

		Tab::BallotValue->set_sql( delete_round => "
			delete ballot_value from ballot_value, ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
			and ballot.id = ballot_value.ballot
		");

		Tab::Ballot->set_sql( delete_round => "
			delete ballot from ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
		");

		Tab::Panel->set_sql( delete_round => "
			delete from panel where round = ?
		");

		Tab::BallotValue->sql_delete_round->execute($round->id);	
		Tab::Ballot->sql_delete_round->execute($round->id);
		Tab::Panel->sql_delete_round->execute($round->id);

	}

	sub justmakeitwork {

		my ($bracket_ref, $entry_by_id_ref, $oddround) = @_;

		my %bracket = %{$bracket_ref};
		my %entry_by_id = %{$entry_by_id_ref};
	
		# NOTE: This counts the number of possible opponents and then pairs a
		# high-high based on that it may be possible to fuse this into another
		# routine, but there's no high-high pairing here now, so I'm not
		
		# normal powermatching has failed, so this just tries to pair the
		# bracket

		#print "in the 'just make it work' disaster pairing mode";
	
		# Mark the number of possible opponents for each team in the bracket;
		# clear any current opponents
		
		foreach my $key ( keys %bracket ) {
		
			$entry_by_id{$key}{'opponent'} = 0;
			
			foreach my $key2 ( keys %bracket ) {
			
					my $canpair = 1;

					if (hasconflict($key, $key2) == 1) { $canpair = 0; print $key2." teams have conflict.<br>";} 

					if ($key == $key2) { $canpair = 0; } 

					if ( $oddround == 0 and $bracket{$key}{'side'} == $bracket{$key2}{'side'} ) { $canpair = 0; } 

				if ( $canpair == 1 ) { $entry_by_id{$key}{'possible_opponents'}++; }

			}
			
		}

		#now pair it
		foreach my $key ( sort { $bracket{$a}->{'possible_opponents'} <=> $bracket{$b}->{'possible_opponents'} } keys(%bracket) ) {

			#if it's an even round, only loop through the aff
			my $sidemarker = 1;
			if ($oddround == 0 and $bracket{$key}{'side'} == 2) { $sidemarker = 0; }

			if ( $entry_by_id{$key}{'opponent'} == 0 and $sidemarker == 1 ) {
				foreach my $oppkey (sort { $bracket{$a}->{'possible_opponents'} <=> $bracket{$b}->{'possible_opponents'} } keys(%bracket)) {
#					print "Trying to pair ".$entry_by_id{$key}{'code'}." vs ".$entry_by_id{$oppkey}{'code'}." ";
					my $canpair = 1;
					if ($entry_by_id{$oppkey}{'opponent'} != 0) { $canpair = 0; }
					if (hasconflict($key, $oppkey) == 1) { $canpair = 0; print $oppkey." teams have conflict.<br>";} 
					if ($key == $oppkey) { $canpair = 0; } 
					if ( $oddround == 0 and $bracket{$key}{'side'} == $bracket{$oppkey}{'side'} ) { $canpair = 0; } 
					if ( $canpair == 1 ) {
						$entry_by_id{$key}{'opponent'} = $oppkey;
						$entry_by_id{$oppkey}{'opponent'} = $key;
#						print "WORKED!  Pairing ".$entry_by_id{$key}{'code'}." vs ".$entry_by_id{$oppkey}{'code'}."<br>";
						last;
					}
				}
			}
		}
		
		if (unpaired == 0) { return "Success"; }
		return "Fail";
	
	}

	
	sub saveit {

		my $debug;
		my ($round, $entry_by_id_ref) = @_;
		my %entry_by_id = %{$entry_by_id_ref};

		my $letter = 1;
		$letter = "A" if $round->event->setting("panel_labels") eq "letters";

		foreach my $key ( keys %entry_by_id ) {		

			if ( $key > -1 and ($entry_by_id{$key}{'sidedue'} == 1 or $entry_by_id{$key}{'opponent'} == -1 ) ) {

				my $bye = 0;
				$bye = 1 if $entry_by_id{$key}{'opponent'} == 1; 

				my $panel = Tab::Panel->create({
					round   => $round->id,
					bye     => $bye,
					letter  => $letter,
					flight  => 1,
					bracket => $entry_by_id{$key}{'bracket'}
				});
				
				#save aff ballot
				my $pullup = 0;
				my $opponent = $entry_by_id{$key}{'opponent'};
				$pullup = 1 if $entry_by_id{$key}{'wins'} < $entry_by_id{$opponent}{'wins'};
				
				Tab::Ballot->create({
					panel  => $panel->id,
					judge  => 0,
					audit  => $bye,
					entry  => $key,
					side   => $entry_by_id{$key}{'sidedue'},
					seed   => $entry_by_id{$key}{'seed'},
					pullup => $pullup
				});
				
				#save neg ballot

				if ( $bye == 0 and $opponent > 0 ) {

					my $pullup = 0;
					$pullup = 1 if $entry_by_id{$key}{'wins'} > $entry_by_id{$opponent}{'wins'}; 

					Tab::Ballot->create({
						panel  => $panel->id,
						judge  => 0,
						audit  => $bye,
						entry  => $opponent,
						side   => $entry_by_id{$opponent}{'sidedue'},
						seed   => $entry_by_id{$opponent}{'seed'},
						pullup => $pullup
					});
				}
				
				$letter++;

			}		
		}
	}

	print "<br>" if $debug;

	if ($debug) { 

		#printing the sorted seeds; just for debugging
		print "<div class='left huge'>";
		print "<table cellpadding='3' width='100%' class='tablesorter'>";
		print "<tr><td>key</td><td>code</td><td>school</td><td>wins</td><td>seed</td><td>oppseed</td><td>SOP</td><td>sideddue</td><td>opponent</td></tr>";

		foreach my $key (sort {$entry_by_id{$a}->{'seed'} <=> $entry_by_id{$b}->{'seed'}} keys(%entry_by_id)) {

			if ($key and $key > -1) {
				print "<tr>";
				print "<td>".$key."</td>";
				print "<td>".$entry_by_id{$key}{'code'}."</td>";
				print "<td>".$entry_by_id{$key}{'school'}."</td>";
				print "<td>".$entry_by_id{$key}{'wins'}."</td>";
				print "<td>".$entry_by_id{$key}{'seed'}."</td>";
				print "<td>".sprintf("%.3f", $entry_by_id{$key}{'oppseed'})."</td>";
				print "<td>".sprintf("%.3f", $entry_by_id{$key}{'SOP'})."</td>";
				print "<td>".$entry_by_id{$key}{'sidedue'}."</td>";
				print "<td>".$entry_by_id{$key}{'opponent'}." ".$entry_by_id{$entry_by_id{$key}{'opponent'}}{'code'}."</td>";
				print "</tr>";
			}
		}
		print "</table>";
		print "<br>";
		print "<table cellpadding='3' width='100%' class='tablesorter'>";
		print "<tr><td>Aff</td><td>W-Sd-SOP</td><td>Neg</td><td>W-Sd-SOP</td></tr>";
		foreach my $key (sort { $entry_by_id{$b}->{'bracket'} <=> $entry_by_id{$a}->{'bracket'} || $entry_by_id{$a}->{'SOP'} <=> $entry_by_id{$b}->{'SOP'} } keys(%entry_by_id)) {
			if ( $key and ($entry_by_id{$key}{'sidedue'} == 1 or $entry_by_id{$key}{'opponent'} == -1 ) ) {
				print "<tr>"; 
				print "<td>".$entry_by_id{$key}{'code'}."</td>";
				print "<td>".$entry_by_id{$key}{'wins'}."-".$entry_by_id{$key}{'seed'}."-".sprintf("%.3f", $entry_by_id{$key}{'SOP'})."</td>";
				my $key2 = $entry_by_id{$key}{'opponent'};
				print "<td>".$entry_by_id{$key2}{'code'}."</td>";
				print "<td>".$entry_by_id{$key2}{'wins'}."-".$entry_by_id{$key2}{'seed'}."-".sprintf("%.3f", $entry_by_id{$key2}{'SOP'})."</td>";
				print "</tr>";
			}
		}
		print "</table>";
	print "</div>";
	}

	$crap = keys %entry_by_id; print "Total spots paired including bye:".$crap."<br>";
	$x = 0;
	foreach my $key ( keys %entry_by_id ) {
		if ( $entry_by_id{$key} != 0 ) { $x++; }
	}
	print "Total teams paired with opponent including bye:".$x."<br>";
	print "All done and saved!<br>";
	$end = time();
	print "<br>processing time: ";
	printf("%.2f\n", $end - $start);

	undef $oddround;

</%perl>
