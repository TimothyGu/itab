<%args> 
	$username => undef
	$password => undef
	$tourn_id => undef
</%args>
<%init>

	use Crypt::PasswdMD5;

	my $now = DateTime->now;

	my $log = $now->mdy('/')." ".$now->hms;
	$log .= " Login attempt by ".$username." from ".$ENV{REMOTE_ADDR}."....";

	$username =~ tr/[A-Z]/[a-z]/;
	$password =~ s/\s+$//g;


	unless ($username) { 
		my $err = "You must enter an email address as a username.  Please try again.";
		Tab::log("Failed: no username entered. $log");
		$m->redirect("$Tab::url_prefix/index/index.mhtml?err=$err");
	}

	unless ($password) { 
		my $err = "You must enter a password.  Please try again.";
		Tab::log("Failed: blank password.  $log");
		$m->redirect("$Tab::url_prefix/index/index.mhtml?err=$err");
	}

	my @accounts = Tab::Account->search(email => $username);

	unless (@accounts) { 
		my $err = "No account with that email address exists on this system.  Please try again.";
		Tab::log("Failed: no such account. $log");
		$m->redirect("$Tab::url_prefix/index/index.mhtml?err=$err");
	}
		
	my $account = shift @accounts;
	
	my $db_password = $account->passhash;
	my $verify_password = unix_md5_crypt($password,$db_password);
		
	unless ($verify_password eq $db_password) { 
	
		my $err = "Your password was not correct";
		Tab::log("Failed: wrong password. $log");
		$m->redirect("$Tab::url_prefix/index/index.mhtml?err=$err");

	}
	
	# To maintain state, the sha keys are encoded.  Change the value below to
	# something unique for your site to maintain a passing fantasy of security.

	my $key = "$Tab::string";
	my $auth = $m->comp("/funclib/generate_randomstring.mas", length => 16);

	my $shauser = Digest::SHA::sha1_hex($key, $account->id);
	my $shakey = Digest::SHA::sha1_hex($key, $auth);


	my $passwordcookie = Apache2::Cookie->new($r,
        -name => 'Tab-AuthKey',
        -value => $shakey,
        -expires => '+96h',
        -path => '/' 
        );

	my $tokencookie = Apache2::Cookie->new($r,
        -name => 'Tab-AuthToken',
        -value => $shauser,
        -expires => '+96h',
        -path => '/'
        );

#	Remove existing sessions to prevent dual logins
	my $allowed_sessions = $account->multiple;
	$allowed_sessions = 1 unless $allowed_sessions;

	foreach my $sess ( sort {$b->id <=> $a->id} $account->sessions) {
		next if $sess->limited;
		$sess->delete unless $allowed_sessions;
		$allowed_sessions--;
	}
        
    my $session = Tab::Session->create( { 
    	account => $account->id,
    	authkey => $shakey,
		userkey => $shauser,
		ip => $ENV{REMOTE_ADDR},
    	timestamp => $now,
    });

    $tokencookie->bake($r);
    $passwordcookie->bake($r);

	$log .= "....Succeeded.";
	Tab::log("$log");

    $m->redirect("$Tab::url_prefix/index/register.mhtml?tourn_id=$tourn_id") if $tourn_id;

    $m->redirect("$Tab::url_prefix/user/home.mhtml");

</%init>
	
