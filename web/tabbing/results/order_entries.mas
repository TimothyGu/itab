<%args>
	$round
	$long_names => undef
	$seed_skip => undef
</%args>
<%init>

	return unless $round;

	my $event = $round->event;
	my $tourn = $event->tourn;
	my $seed = $tourn->start->epoch;

	my $tb_set = $round->tb_set if $round->tb_set;

	unless ($tb_set) {  
		my $err = "Round ".$round->realname." does not have a tiebreaker set applied to it.  Please pick one and try again";
		$m->redirect("/setup/schedule/event.mhtml?event_id=".$event->id."&err=$err");
	}

	#Settings
	my $mfl_time_violation = $tb_set->setting("mfl_time_violation");
	my $truncate = $tb_set->setting("truncate_ranks_to") if $tb_set->setting("truncate_ranks_to");
	my $truncate_to_smallest = $tb_set->setting("truncate_to_smallest");
	my $noshows_never_break = $tb_set->setting("noshows_never_break");
	my $equal_elims++ if $tb_set->setting("equal_elims");

	my %used_tier = (); 
	my $all;
	my $elim;

	my %tb_tiers = ();
	my %tbid_tiers = ();

	foreach my $tb ($tb_set->tiebreaks) { 
		$used_tier{$tb->count}++;
		$all++ if $tb->count eq "all";
		$elim++ if $tb->count eq "elim";
		push @{$tb_tiers{$tb->priority}}, $tb;
		push @{$tbid_tiers{$tb->priority}}, $tb->id;
	}   

	# Get the data you'll need for Teh Sortingz.
	my $dbh = Tab::DBI->db_Main();

    my %entry_wins;

    my %entry_scores;
    my %entry_panels;
	my %entry_round_scores;
    my %entry_school;
    my %entry_event;
    my %entry_code;
    my %entry_dq;
    my %entry_noshow;
	my %entry_round_bye;
	my %entry_round_panel_bye;

	my %entry_ranks;  		#For opp_ranks calculation
	my %entry_points;		#For opp_points calculation

    my %score_entry;
    my %score_tag;
    my %score_value;
    my %score_panel;
    my %score_judge;
    my %score_event;
	my %score_chair;
	my %score_tv;

	my %round_panels;

	my %panel_letter;
	my %panel_roundname;
	my %panel_entries;

	my @rounds;
	my %round_type;
	my %round_name;

	my @scores;
	my @entries;

	my $last_elim_wins;

	if ($all) { 

		my $sth = $dbh->prepare("
			select value.id, entry.id, entry.code, entry.dq, round.type, round.name, round.id, value.tag, value.value, event.id, panel.id, 
			ballot.judge, ballot.noshow, ballot.tv, panel.letter, entry.school, ballot.chair, ballot.bye, panel.bye
			from ballot_value value, ballot, panel, round, event, entry, entry_student, student
			where value.ballot = ballot.id
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.event = event.id
			and event.id = ".$event->id."
			and ballot.entry = entry.id
			and entry.dropped != 1
			and entry.waitlist != 1
			and entry.unconfirmed != 1
			and entry.id = entry_student.entry
			and entry_student.student = student.id
			group by value.id
			order by event.id, round.name
		");

		$sth->execute();

		while (my ($id, $entry, $code, $dq, $type, $roundname, $round, $tag, $value, $event, $panel, $judge, $noshow, $tv, $letter,  $school, $chair, $bye, $pbye)  = $sth->fetchrow_array() ) {

			push @rounds, $round;
			$round_type{$round} = $type;
			$round_type{$round} = "prelim" if $type eq "preset" || $type eq "highhigh" || $type eq "highlow" || $type eq "random" || $type eq "power";
			$round_name{$round} = $roundname;
			push @{$round_panels{$round}}, $panel;

			push @entries, $entry;
			push @{$entry_scores{$entry}}, $id;
			push @{$entry_panels{$entry}}, $panel;
			push @{$entry_round_scores{$entry."-".$round}}, $id;

			$entry_school{$entry} = $school;
			$entry_event{$entry} = $event;
			$entry_code{$entry} = $code;
			$entry_dq{$entry} = $dq if $dq;
			$entry_noshow{$entry}++ if $noshow;

			$entry_round_bye{$round."-".$entry} = $bye;
			$entry_round_panel_bye{$round."-".$entry} = $pbye;

			push @scores, $id;
			$score_tag{$id} = $tag;
			$score_entry{$id} = $entry;
			$score_value{$id} = $value;
			$score_panel{$id} = $panel;
			$score_judge{$id} = $judge;
			$score_event{$id} = $event;
			$score_chair{$id}++ if $chair;
			$score_tv{$id} = $tv if $tv;

			$panel_letter{$panel} = $letter;
			$panel_roundname{$panel} = $roundname;
			push @{$panel_entries{$panel}}, $entry;

		}

	} else { 

		foreach my $key (keys %used_tier) { 

			if ($key eq "last elim" || $key eq "last_elim") { 

				%entry_wins = $m->comp("/funclib/entry_wins.mas", event => $event, round => $round, last => 1);
				$last_elim_wins++;

				my $sth = $dbh->prepare("
					select value.id, entry.id, entry.code, entry.dq, round.type, round.name, round.id, value.tag, value.value, event.id, panel.id, 
					ballot.judge, ballot.noshow, ballot.tv, panel.letter, entry.school, ballot.chair, ballot.bye, panel.bye
					from ballot_value value, ballot, panel, round, event, entry, entry_student, student
					where value.ballot = ballot.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.event = event.id
					and round.id = ".$round->id."
					and ballot.entry = entry.id
					and entry.dropped != 1
					and entry.waitlist != 1
					and entry.unconfirmed != 1
					and entry.id = entry_student.entry
					and entry_student.student = student.id
					group by value.id
					order by event.id, round.name
				");

				$sth->execute();

				while (my ($id, $entry, $code, $dq, $type, $roundname, $round, $tag, $value, $event, $panel, $judge, $noshow, $tv, $letter,  $school, $chair, $bye, $pbye)  = $sth->fetchrow_array() ) {


					push @rounds, $round;
					$round_type{$round} = $type;
					$round_type{$round} = "prelim" if $type eq "preset" || $type eq "highhigh" || $type eq "highlow" || $type eq "random" || $type eq "power";
					$round_name{$round} = $roundname;
					push @{$round_panels{$round}}, $panel;

					push @entries, $entry;
					push @{$entry_scores{$entry}}, $id;
					push @{$entry_panels{$entry}},$panel;
					push @{$entry_round_scores{$entry."-".$round}}, $id;

					$entry_school{$entry} = $school;
					$entry_event{$entry} = $event;
					$entry_code{$entry} = $code;
					$entry_dq{$entry} = $dq if $dq;
					$entry_noshow{$entry}++ if $noshow;
					$entry_round_bye{$round."-".$entry} = $bye;
					$entry_round_panel_bye{$round."-".$entry} = $pbye;

					push @scores, $id;
					$score_tag{$id} = $tag;
					$score_entry{$id} = $entry;
					$score_value{$id} = $value;
					$score_panel{$id} = $panel;
					$score_judge{$id} = $judge;
					$score_event{$id} = $event;
					$score_chair{$id}++ if $chair;
					$score_tv{$id} = $tv;
					

					$panel_letter{$panel} = $letter;
					$panel_roundname{$panel} = $roundname;
					push @{$panel_entries{$panel}}, $entry;
				}

			} else {

				my $sth = $dbh->prepare("
					select value.id, entry.id, entry.code, entry.dq, round.type, round.name, round.id, value.tag, value.value, event.id, panel.id, 
					ballot.judge, ballot.noshow, ballot.tv, panel.letter, entry.school, ballot.chair, ballot.bye, panel.bye
					from ballot_value value, ballot, panel, round, event, entry, entry_student, student
					where value.ballot = ballot.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.event = event.id
					and event.id = ".$event->id."
					and round.name <= ".$round->id."
					and ballot.entry = entry.id
					and entry.dropped != 1
					and entry.waitlist != 1
					and entry.unconfirmed != 1
					and entry.id = entry_student.entry
					and entry_student.student = student.id
					group by value.id
					order by event.id, round.name
				");

				$sth->execute();

				while (my ($id, $entry, $code, $dq, $type, $roundname, $round, $tag, $value, $event, $panel, $judge, $noshow, $tv, $letter,  $school, $chair, $bye, $pbye)  = $sth->fetchrow_array() ) {

					push @rounds, $round;
					$round_type{$round} = $type;
					$round_type{$round} = "prelim" if $type eq "preset" || $type eq "highhigh" || $type eq "highlow" || $type eq "random" || $type eq "power";
					$round_name{$round} = $roundname;
					push @{$round_panels{$round}}, $panel;

					push @entries, $entry;
					push @{$entry_scores{$entry}}, $id;
					push @{$entry_panels{$entry}},$panel;
					push @{$entry_round_scores{$entry."-".$round}}, $id;

					$entry_school{$entry} = $school;
					$entry_event{$entry} = $event;
					$entry_code{$entry} = $code;
					$entry_dq{$entry} = $dq if $dq;
					$entry_noshow{$entry}++ if $noshow;
					$entry_round_bye{$round."-".$entry} = $bye;
					$entry_round_panel_bye{$round."-".$entry} = $pbye;

					push @scores, $id;
					$score_tag{$id} = $tag;
					$score_entry{$id} = $entry;
					$score_value{$id} = $value;
					$score_panel{$id} = $panel;
					$score_judge{$id} = $judge;
					$score_event{$id} = $event;
					$score_chair{$id}++ if $chair;
					$score_tv{$id} = $tv;

					$panel_letter{$panel} = $letter;
					$panel_roundname{$panel} = $roundname;
					push @{$panel_entries{$panel}}, $entry;

				}
			}
		}
	}

	my %rseen = (); 
	@rounds = grep { ! $rseen{$_}++ } @rounds;

	my @all_rounds;

	my %round_done;
	my $round_name = $round->name;

	foreach my $all_round (@rounds) { 

		next if $round_name{$all_round} > $round_name;  # Do not measure the future
		push @all_rounds, $all_round;

		#Uniq the panels so there's no double counting
		my %pseen = (); 
		@{$round_panels{$all_round}} = grep { ! $pseen{$_}++ } @{$round_panels{$all_round}};

		foreach my $panel (@{$round_panels{$all_round}}) {   
			#Uniq the panel entries so there's no double counting;
			my %eseen = (); 
			@{$panel_entries{$panel}} = grep { ! $eseen{$_} ++ } @{$panel_entries{$panel}};
		}

	}

	my %dq_panel_threshold = ();

	my @keys = keys %entry_dq;

	foreach my $entry (keys %entry_dq) { 
		next unless $entry_dq{$entry};

		foreach my $score (@{$entry_scores{$entry}}) { 
			next unless $score_tag{$score} eq "rank";
			$dq_panel_threshold{$score_panel{$score}."-".$score_judge{$score}} = $score_value{$score};
		}
	}

	my %round_truncate = ();

	if ($truncate_to_smallest) { 

		foreach my $round (@all_rounds) { 

			$round_truncate{$round} = $truncate; #Upper limit is the hard cap, if any

			foreach my $panel (@{$round_panels{$round}}) { 
				my $size = scalar @{$panel_entries{$panel}} if $panel_entries{$panel};
				$round_truncate{$round} = $size unless $round_truncate{$round};
				$round_truncate{$round} = $size if $round_truncate{$round} > $size;
			}

		}
	}

	my %eseen = (); 
	@entries = grep { ! $eseen{$_} ++ } @entries;

	if ($round && ($round->type eq "elim" || $round->type eq "final")) { 

		#Eliminate everyone who has not advanced to the elim round in question.

		my @counted;
		my %last_round;
		my %done;

		foreach my $entry (@entries) { 

			next if $done{$entry}++;

			foreach my $panel (@{$entry_panels{$entry}}) { 
				$last_round{$entry} = $panel_roundname{$panel} if $last_round{$entry} < $panel_roundname{$panel};
			}

			next if $last_round{$entry} < $round_name;
			push @counted, $entry;
		}

		@entries = @counted;
	}

	my %entry_tbs = ();
	my %tier_descs = ();
	my %tier_long_descs = ();
	my %tier_dir = ();

	my $win_loss;
	my $judge_var;

	my @rinr_rounds;

	my $opp_seed;
	my $own_seed;

	foreach my $key (sort keys %tb_tiers) { 

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			$opp_seed++ if $tb->name eq "opp_seed";
			$own_seed++ if $tb->name eq "seed";

			$win_loss++ if $tb->name eq "winloss";
			$win_loss++ if $tb->name eq "opp_wins";
			$judge_var++ if $tb->name eq "judgevar";

			if ($tb->name eq "rankinround") { 
				foreach my $round (@all_rounds) { 
					if ($round_type{$round} eq $tb->count) { 
						push @rinr_rounds, $round;
					} elsif ($tb->count eq "all") { 
						push @rinr_rounds, $round;
					}
				}
			}
		}
	}

	%entry_wins = $m->comp("/funclib/entry_wins.mas", event => $event, round => $round) if $win_loss && not defined $last_elim_wins;

	my ($judge_avg_ref, $judge_ballot_count_ref, $judge_total_ref) = $m->comp("/funclib/judge_points_average.mas", event => $event) if $judge_var;

	my %entry_rankinround = ();

	my %rinr_seen = (); 
	@rinr_rounds = grep { ! $rinr_seen{$_} ++ } @rinr_rounds;

	foreach my $round_id (@rinr_rounds) { 

		my $round = Tab::Round->retrieve($round_id);

		my ($entries_ref, @others) = $m->comp("/tabbing/results/order_entries.mas", round => $round);

		my %absolute_rank;

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry (@{${$entries_ref}{$key}}) {
				$absolute_rank{$entry} = $key;
			}
		}

		foreach my $panel (@{$round_panels{$round}}) { 
			my $rank = 1;

			foreach my $entry (sort {$absolute_rank{$a} <=> $absolute_rank{$b}} @{$panel_entries{$panel}}) { 
				$entry_rankinround{$entry."-".$round} = $rank;
				$rank++;
			}
		}
	}

	my $opp_ranks;
	my $opp_points;
	my $ranks;
	my $points;

	ENTRY:
	foreach my $entry (@entries) { 
		foreach my $this_round (@rounds) { 

			my %erseen = ();  
			@{$entry_round_scores{$entry."-".$round}} = grep { ! $erseen{$_}++ } @{$entry_round_scores{$entry."-".$round}};

			unless (@{$entry_round_scores{$entry."-".$round}}) { 
				$entry_noshow{$entry}++;
				next ENTRY;
			}
		}
	}

	my %entry_seed;
	my %opp_entry_seed;

	my $test_round;
	my $seed_skipper++;

	if ($opp_seed || $own_seed) { 

		$test_round = $round if ($round->type ne "elim" && $round->type ne "final");

		unless ($test_round) { 

			my $test_round_id;

			foreach my $round (@rounds) { 
				$test_round_id = $round if $round_type{$round} eq "prelim";
			}
			$test_round = Tab::Round->retrieve($test_round_id);
			undef $seed_skipper;
			Tab::debuglog("Calculating on the basis of ".$test_round->realname." from round ".$round->realname);
		}
	}

	if ($opp_seed && not defined $seed_skip) { 
		
		my ($entries_ref, @others) = $m->comp("/tabbing/results/order_entries.mas", round => $test_round, seed_skip => $seed_skipper);

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry (@{${$entries_ref}{$key}}) {
				$opp_entry_seed{$entry} = $key;
			}
		}

	}

	if ($own_seed && not defined $seed_skip) { 

		my ($entries_ref, @others) = $m->comp("/tabbing/results/order_entries.mas", round => $test_round, seed_skip => $seed_skipper);

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry (@{${$entries_ref}{$key}}) {
				$entry_seed{$entry} = $key;
			}
		}
	}

	my $seed_done;
	my $opp_seed_done;

	foreach my $key (sort keys %tb_tiers) { 

		my $tier_desc;
		my $tier_long_desc;

		next if $seed_done && $seed_skip;
		next if $opp_seed_done && $seed_skip;

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			my $tb_name = $tb->name;

			$tier_dir{$key} = "down" if (
				$tb_name eq "winloss" ||
				$tb_name eq "reciprocals" ||
				$tb_name eq "points" ||
				$tb_name eq "ballots" ||
				$tb_name eq "judgepref" ||
				$tb_name eq "opp_points" ||
				$tb_name eq "opp_wins" ||
				$tb_name eq "judgevar");

			$tier_dir{$key} = "up" if (
				$tb_name eq "ranks" ||
				$tb_name eq "opp_seed" ||
				$tb_name eq "seed" ||
				$tb_name eq "opp_ranks" ||
				$tb_name eq "chair_ranks" ||
				$tb_name eq "rankinround" ||
				$tb_name eq "coinflip");

			$tier_desc .= "+" if $tier_desc;
			$tier_long_desc .= "+" if $tier_long_desc;

			$tier_desc .= "Rnk" if $tb_name eq "ranks";
			$tier_long_desc .= "Ranks" if $tb_name eq "ranks";

			$tier_desc .= "Pts" if $tb_name eq "points";
			$tier_long_desc .= "Speaker Points" if $tb_name eq "points";

			$tier_desc .= "Rcp" if $tb_name eq "reciprocals";
			$tier_long_desc .= "Reciprocals" if $tb_name eq "reciprocals";

			$tier_desc .= "JP" if $tb_name eq "judgepref";
			$tier_long_desc .= "Judge Preferences" if $tb_name eq "judgepref";

			$tier_desc .= "Rnd" if $tb_name eq "coinflip";
			$tier_long_desc .= "Random" if $tb_name eq "coinflip";

			$tier_desc .= "ORk" if $tb_name eq "opp_ranks";
			$tier_long_desc .= "Opponents Ranks" if $tb_name eq "opp_ranks";

			$tier_desc .= "CRk" if $tb_name eq "chair_ranks";
			$tier_long_desc .= "Chair Judge Ranks" if $tb_name eq "chair_ranks";

			$tier_desc .= "SRk" if $tb_name eq "rankinround";
			$tier_long_desc .= "Rank within Section" if $tb_name eq "rankinround";

			$tier_desc .= "W" if $tb_name eq "winloss";
			$tier_long_desc .= "Wins" if $tb_name eq "winloss";

			$tier_desc .= "Sd" if $tb_name eq "seed";
			$tier_long_desc .= "Prelim Seed Position" if $tb_name eq "seed";

			$tier_desc .= "OSd" if $tb_name eq "opp_seed";
			$tier_long_desc .= "Opponent Seed Position" if $tb_name eq "opp_seed";

			$tier_desc .= "OW" if $tb_name eq "opp_wins";
			$tier_long_desc .= "Opponent Wins" if $tb_name eq "opp_wins";

			$tier_desc .= "OPt" if $tb_name eq "opp_points";
			$tier_long_desc .= "Opponent Points" if $tb_name eq "opp_points";

			$tier_desc .= "JV" if $tb_name eq "judgevar";
			$tier_long_desc .= "Judge Points Variance" if $tb_name eq "judgevar";

			$tier_desc .= "Bal" if $tb_name eq "ballots";
			$tier_long_desc .= "Ballot Total" if $tb_name eq "ballots";

			$points++ if $tb_name eq "points";
			$ranks++ if $tb_name eq "ranks";

			$opp_seed++ if $tb_name eq "opp_seed";
			$own_seed++ if $tb_name eq "seed";
			$opp_ranks++ if $tb_name eq "opp_ranks" && not defined $ranks;
			$opp_points++ if $tb_name eq "opp_points" && not defined $points;

			my $tb_highlow = $tb->highlow;

			if ($tb_highlow) {

				$tier_desc .= " -".$tb->highlow_count;
				$tier_long_desc .= " -".$tb->highlow_count;

				$tier_desc .= "HL" if $tb_highlow == 1 || $tb_highlow == 2;
				$tier_long_desc .= " Best & Worst" if $tb_highlow == 1 || $tb_highlow == 2;

				$tier_desc .= "H" if $tb_highlow == 3;
				$tier_long_desc .= " Best" if $tb_highlow == 3;

				$tier_desc .= "L" if $tb_highlow == 4;
				$tier_long_desc .= " Worst" if $tb_highlow == 4;
			}

			$tier_long_desc .= " in ".ucfirst($tb->count) if $tb->count;
			$tier_long_desc .= " Rounds" if $tb->count && ($tb->count eq "all");
			$tier_long_desc .= "s" if $tb->count && ($tb->count eq "prelim" || $tb->count eq "elim");
			$tier_long_desc .= " multplied by ".$tb->multiplier if $tb->multiplier != 1;
			$tier_desc .= " x".$tb->multiplier if $tb->multiplier != 1;

			$points++ if $opp_points;
			$opp_ranks++ if $opp_ranks;

		}

		$tier_desc = "SOP" if $tier_desc eq "Sd+OSd";
		$tier_desc = "SOP" if $tier_desc eq "OSd+Sd";

		$tier_descs{$key} = $tier_desc;
		$tier_long_descs{$key} = $tier_long_desc;

		my %tb_name;
		my %tb_rounds;
		my %tb_highlow;
		my %tb_highlow_count;
		my %tb_multiplier;

		foreach my $tb (@{$tb_tiers{$key}}) { 

			$tb_name{$tb->id} = $tb->name;
			$tb_highlow{$tb->id} = $tb->highlow;
			$tb_highlow_count{$tb->id} = $tb->highlow_count;
			$tb_multiplier{$tb->id} = $tb->multiplier;


			foreach my $oround (@all_rounds) { 
				push (@{$tb_rounds{$tb->id}}, $oround) if $round_type{$oround} eq $tb->count;
				push (@{$tb_rounds{$tb->id}}, $oround) if $tb->count eq "all";
				push (@{$tb_rounds{$tb->id}}, $oround) if ($round_type{$oround} eq "elim" || $round_type{$oround} eq "final") && ($tb->count eq "last elim" || $tb->count eq "last_elim");
			}

		}

		ENTRY:
		foreach my $entry (@entries) { 

			my %seen = (); 
			@{$entry_panels{$entry}} = grep { ! $seen{$_} ++ } @{$entry_panels{$entry}};

			my $tier_total;

			foreach my $tb (@{$tbid_tiers{$key}}) { 

				my $name = $tb_name{$tb};
				next unless $tb_rounds{$tb};
				my @rounds = @{$tb_rounds{$tb}};

				my $tb_highlow = $tb_highlow{$tb};
				my $tb_highlow_count = $tb_highlow_count{$tb};

				my $total; 

				if ($name eq "winloss") { 

					$total += $entry_wins{$entry};

				} elsif ($name eq "ranks" || $name eq "reciprocals" || $name eq "chair_ranks") { 

					my @drop_best;
					my @drop_worst;

					my $count;

					foreach my $this_round (@rounds) { 

						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 

							if ($score_tag{$score} eq "rank") { 

								next if $name eq "chair_ranks" && $score_chair{$score} < 1;
							
								my $rank = $score_value{$score};

								if ($dq_panel_threshold{$score_panel{$score}."-".$score_judge{$score}}) { 
									$rank-- if $dq_panel_threshold{$score_panel{$score}."-".$score_judge{$score}} < $rank;
								}

								# Bump the rank up if it's a time violation.  Truncation below will correct if this makes it bigger (ie if the TV was last place);
								$rank++ if $score_tv{$score} && $mfl_time_violation;

								# Promote anyone over the hard cap for truncation
								$rank = $truncate if $truncate && $rank > $truncate && $round_type{$this_round} eq "prelim";

								# Promote anyone over the per-round floating cap for truncation
								$rank = $round_truncate{$this_round} if $truncate_to_smallest && $rank > $round_truncate{$this_round} && $round_type{$this_round} eq "prelim";

								#Rank cannot be greater than the size of the round
								$rank = scalar @{$panel_entries{$score_panel{$score}}} if $rank > scalar @{$panel_entries{$score_panel{$score}}};

								$total += $rank if $name eq "ranks" || $name eq "chair_ranks";
								$total += (1/$rank) if $rank && $name eq "reciprocals";
								$count++ if $name eq "ranks";

								if ($tb_highlow) {  

									#drop the best

									if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {

										if (scalar @drop_best < $tb_highlow_count) {
											push @drop_best, $rank;
										} else {
											my $least_best = pop @drop_best;
											push @drop_best, $least_best if $least_best <= $rank;
											push @drop_best, $rank if $least_best > $rank;
										}

										@drop_best = sort {$a <=> $b} @drop_best;
									}

									#drop the worst

									if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {

										if (scalar @drop_worst < $tb_highlow_count) {
											push @drop_worst, $rank;
										} else {
											my $least_worst = pop @drop_worst;
											push @drop_worst, $least_worst if $least_worst >= $rank;
											push @drop_worst, $rank if $least_worst < $rank;
										}

										@drop_worst = sort {$b <=> $a} @drop_worst;
									}
								}
							}
						}
					}

                    foreach my $rank (@drop_best, @drop_worst) {
                        $total -= $rank if $name eq "ranks" || $name eq "chair_ranks";
                        $total -= 1/$rank if $name eq "reciprocals";
						$count-- if $name eq "ranks";
                    }

					$total = sprintf "%.2f", $total;  #round to 2 decimal places for recips;
					$entry_ranks{$entry} = $total / $count if $count;

				} elsif ($name eq "points") { 

					my @drop_best;
					my @drop_worst;

					my $count;
					my $bye;

					foreach my $this_round (@rounds) { 

						$bye++ if $entry_round_bye{$this_round."-".$entry};
						next if $entry_round_bye{$this_round."-".$entry};

						$bye++ if $entry_round_panel_bye{$this_round."-".$entry};
						next if $entry_round_panel_bye{$this_round."-".$entry};

						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 

							if ($score_tag{$score} eq "points") { 
					
								my $points = $score_value{$score};
								$total += $points;
								$count++;

								if ($tb_highlow) {  

									#drop the best

									if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {

										if (scalar @drop_best < $tb_highlow_count) {
											push @drop_best, $points;
										} else {
											my $least_best = pop @drop_best;
											push @drop_best, $least_best if $least_best <= $points;
											push @drop_best, $points if $least_best > $points;
										}

										@drop_best = sort {$a <=> $b} @drop_best;
									}

									#drop the worst

									if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {

										if (scalar @drop_worst < $tb_highlow_count) {
											push @drop_worst, $points;
										} else {
											my $least_worst = pop @drop_worst;
											push @drop_worst, $least_worst if $least_worst >= $points;
											push @drop_worst, $points if $least_worst < $points;
										}

										@drop_worst = sort {$b <=> $a} @drop_worst;
									}
								}
							}
						}
					}

					if ($bye) { 
						my $average = $total / $count if $count;
						$total += $average * $bye;
					}

                    foreach my $points (@drop_best, @drop_worst) {
                        $total -= $points;
						$count--;
                    }

					$total = sprintf "%.2f", $total;  #round to 2 decimal places for points;
					$entry_points{$entry} = $total / $count if $count; #used for opp wins and opp points.


				} elsif ( $name eq "ballots") { 

					foreach my $this_round (@rounds) { 
						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 
							if ($score_tag{$score} eq "ballot") { 
								$total++ if $score_value{$score} == 1;
							}
						}
					}
						
				} elsif ( $name eq "coinflip") { 

					# This is only semi random; product of the date epoch and
					# the random entry ID's last four digits.  But it will be
					# the same every time this function is run and random
					# enough in that it cannot be pre-guessed easily.

					my $random_seed = $entry * $seed;
					$total = substr($random_seed, -8, -3);

				} elsif ( $name eq "judgepref") { 

					my $chosen_panel;
					my @chosen_entries;

					foreach my $this_round (@rounds) { 

						PANEL:
						foreach my $panel (@{$round_panels{$this_round}}) {    #Only counts in the current round;
							my @entries = @{$panel_entries{$panel}};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						} 

						my %beseen = (); 
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entry_tbs{$entry."-".$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) { 
							next if $oentry == $entry;
							my $test_string;
							foreach my $okey (sort keys %tb_tiers) { 
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entry_tbs{$oentry."-".$okey};
							}
							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 1) { 

							my $tie_id = shift @ties;

							my %judge_score = ();

							if ($chosen_panel && $entry) { 

								my %done;
								foreach my $score (@{$entry_scores{$entry}}) { 
									next if $done{$score}++;
									next unless $score_tag{$score} eq "rank";
									next unless $score_panel{$score} == $chosen_panel;
									$judge_score{$score_judge{$score}} = $score_value{$score};
								}

								foreach my $tie_score (@{$entry_scores{$tie_id}}) {
									next if $done{$tie_score}++;
									next unless $score_tag{$tie_score} eq "rank";
									next unless $score_panel{$tie_score} == $chosen_panel;
									$total++ if $score_value{$tie_score} > $judge_score{$score_judge{$tie_score}}; #If my rank is better (lower) than the tie's rank, I get a JP point
								}
							}
						}
					}

				} elsif ( $name eq "rankinround") { 

					foreach my $this_round (@rounds) { 
						$total += $entry_rankinround{$entry."-".$this_round};
					}

				} elsif ( $name eq "opp_wins") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entry_panels{$entry}}) { 

						next if $panel_roundname{$panel} > $round_name;

						foreach my $other (@{$panel_entries{$panel}}) { 
							next if $other == $entry;
							$sub_total += $entry_wins{$other};
							$count++;
						}
					}

					$total += sprintf "%.2f", $sub_total/$count if $count;

				} elsif ( $name eq "opp_points") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entry_panels{$entry}}) { 
						
						next if $panel_roundname{$panel} > $round_name;

						foreach my $other (@{$panel_entries{$panel}}) { 
							next if $other == $entry;
							$sub_total += $entry_points{$other};
							$count++;
						}
					}

					my $avg = sprintf "%.2f", $sub_total / $count if $count;
					$total += $avg;

				} elsif ( $name eq "opp_ranks") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entry_panels{$entry}}) { 

						next if $panel_roundname{$panel} > $round_name;

						foreach my $other (@{$panel_entries{$panel}}) { 
							next if $other == $entry;
							$sub_total += $entry_ranks{$other};
							$count++;
						}
					}

					my $avg = sprintf "%.2f", $sub_total / $count if $count;
					$total += $avg;

				} elsif ( $name eq "seed") { 

					$seed_done++;
					$total += $entry_seed{$entry};

				} elsif ( $name eq "opp_seed") { 

					$opp_seed_done++;
					my $count;
					my $sub_total;

					foreach my $panel (@{$entry_panels{$entry}}) { 

						next if $panel_roundname{$panel} > $round_name;

						foreach my $other (@{$panel_entries{$panel}}) { 
							next if $other == $entry;
							$sub_total += $opp_entry_seed{$other};
							$count++;
						}
					}

					my $avg = sprintf "%.2f", $sub_total / $count if $count;
					$total += $avg;


				} elsif ( $name eq "judgevar") { 

					my $count;
					my $sub_total;

					foreach my $this_round (@rounds) { 
						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 
							next unless $score_tag{$score} eq "points";

	#						my $judge_totals = ${$judge_total_ref}{$score_judge{$score}};
	#						my $judge_ballots = ${$judge_ballot_count_ref}{$score_judge{$score}};

	#						$judge_totals -= $score_value{$score};
	#						$judge_ballots--;

	#						my $judge_avg = $judge_totals / $judge_ballots if $judge_ballots;
							$sub_total += $score_value{$score} - ${$judge_avg_ref}{$score_judge{$score}};
							$count++;
						}
					}

					my $avg = sprintf "%.2f", $sub_total/$count if $count;
					$total += $avg;

				}

				$tier_total += $total * $tb_multiplier{$tb} if $tb_multiplier{$tb};

			}

			$entry_tbs{$entry."-".$key} = $tier_total;

		}

	}

	if ($opp_points || $opp_ranks) { 
		
		my $err;
		$err .= "Danger Will Robinson!<br />You have defined Opp Points as a tiebreaker without first defining Points.  That cannot work both technically and philosophically.  Fix please! <br /><br />" if $opp_points;
		$err .= "Danger Will Robinson!<br />You have defined Opp Ranks as a tiebreaker without first defining Ranks.  That cannot work both technically and philosophically.  Fix please!" if $opp_ranks;
		$m->redirect("/setup/rules/tiebreaks.mhtml?tb_set_id=".$tb_set->id."&err=$err");

	}

	foreach my $key (reverse sort keys %tb_tiers) { 
		@entries = sort { int(100 * $entry_tbs{$a."-".$key}) <=> int(100 * $entry_tbs{$b."-".$key})  } @entries if $tier_dir{$key} eq "up";
		@entries = sort { int(100 * $entry_tbs{$b."-".$key}) <=> int(100 * $entry_tbs{$a."-".$key})  } @entries if $tier_dir{$key} eq "down";
	}

	my %panel_rank = ();
	my %entry_letter = ();

	if ($equal_elims) { 

		foreach my $panel (@{$round_panels{$round->id}}) { 

			my @pan_entries = @{$panel_entries{$panel}};

			foreach my $key (reverse sort keys %tb_tiers) { 
				@pan_entries = sort { $entry_tbs{$a."-".$key} <=> $entry_tbs{$b."-".$key}  } @pan_entries if $tier_dir{$key} eq "up";
				@pan_entries = sort { $entry_tbs{$b."-".$key} <=> $entry_tbs{$a."-".$key} } @pan_entries if $tier_dir{$key} eq "down";
			}

			my $count = 1;

			my %already; 

			foreach my $pe (@pan_entries) { 
				next if $already{$pe};
				next if $entry_dq{$pe};
				$already{$pe}++;
				$panel_rank{$pe} = $count++;
				$entry_letter{$pe} = $panel_letter{$panel};
			}
		}
	
		@entries = sort { $entry_letter{$a} cmp $entry_letter{$b} } @entries;
		@entries = sort { $panel_rank{$a} <=> $panel_rank{$b} } @entries;

	} else { 
		foreach my $panel (@{$round_panels{$round->id}}) { 
			foreach my $pe (@{$panel_entries{$panel}}) { 
				$entry_letter{$pe} = $panel_letter{$panel};
			}
		}

	}


	@entries = sort { $entry_noshow{$a} <=> $entry_noshow{$b} } @entries if $noshows_never_break;

	my $count;
	my %entry_by_place = ();
	
	my $last_string;
	my $delayed_count;

	foreach my $entry (@entries) { 

		next if $entry_dq{$entry};

		my $tier_string;

		foreach my $key (sort keys %tb_tiers) { 
			$tier_string .= "-" if $tier_string;
			$tier_string .= $entry_tbs{$entry."-".$key};
		}

		if ($tier_string eq $last_string) { 
			$delayed_count++;
		} else {
			$count++;
			$count += $delayed_count;
			undef $delayed_count;
		}

		$last_string = $tier_string;
		push (@{$entry_by_place{$count}}, $entry);
	}

	return (\%entry_by_place, \%entry_tbs, \%tier_descs, \%entry_noshow, \%tier_dir, \%panel_rank, \%entry_letter, \%tier_long_descs, \%entry_code);

</%init>
